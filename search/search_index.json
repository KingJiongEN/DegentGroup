{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Degent Group Documentation","text":"<p>Welcome to the Degent Group documentation. Degent Group is an AI-powered chat system that integrates with Telegram and provides NFT creation, bargaining, and artwork generation capabilities.</p>"},{"location":"#system-overview","title":"System Overview","text":"<pre><code>graph TB\n    subgraph Frontend\n    TW[Twitter API]\n    TG[Telegram Bot]\n    BC[Blockchain API]\n    end\n\n    subgraph Application Layer\n    AS[Agent Service]\n    DS[Dialog Service]\n    NS[NFT Service]\n    WS[Wallet Service]\n    MS[Memory Service]\n    end\n\n    subgraph AI Engine\n    LLM[GPT-4]\n    IM[Image Generator]\n    end\n\n    subgraph Storage\n    DB[(Database)]\n    Cache[(Redis)]\n    IPFS[(IPFS)]\n    Chain[Blockchain]\n    end\n\n    TW --&gt; AS\n    TG --&gt; AS\n    BC --&gt; WS\n\n    AS --&gt; DS\n    AS --&gt; NS\n    AS --&gt; WS\n    AS --&gt; MS\n\n    DS --&gt; LLM\n    NS --&gt; IM\n    NS --&gt; IPFS\n\n    DS --&gt; Cache\n    MS --&gt; DB\n    WS --&gt; Chain\n    NS --&gt; Chain\n</code></pre>"},{"location":"#key-features","title":"Key Features","text":"<ul> <li>\ud83e\udd16 Telegram Bot Integration</li> <li>\ud83c\udfa8 AI Artwork Generation</li> <li>\ud83d\udcb0 NFT Creation and Trading</li> <li>\ud83e\udd1d Automated Bargaining System</li> <li>\ud83d\udc65 Group Chat Management</li> </ul>"},{"location":"#quick-links","title":"Quick Links","text":"<ul> <li>Installation Guide</li> <li>Basic Bot Tutorial</li> <li>API Reference</li> <li>Examples</li> </ul>"},{"location":"#support","title":"Support","text":"<p>For support, please open an issue on our GitHub repository. </p>"},{"location":"api/agent-model/","title":"Agent Model API Reference","text":"<p>Comprehensive documentation for the TeleAgent Agent Model system, which handles AI agent behaviors and interactions.</p>"},{"location":"api/agent-model/#usergroupagent","title":"UserGroupAgent","text":"<p>The main class for managing group chat interactions and user behavior.</p>"},{"location":"api/agent-model/#constructor","title":"Constructor","text":"<pre><code>def __init__(\n    self,\n    name: str,\n    system_message: str,\n    llm_config: dict = None,\n    memory_config: dict = None,\n    **kwargs\n):\n    \"\"\"\n    Initialize UserGroupAgent.\n\n    Args:\n        name (str): Name of the agent\n        system_message (str): Base system message defining agent behavior\n        llm_config (dict, optional): LLM configuration containing:\n            - model (str): Model name (e.g., \"gpt-4\")\n            - temperature (float): Response randomness\n            - max_tokens (int): Maximum response length\n        memory_config (dict, optional): Memory configuration containing:\n            - max_history (int): Maximum conversation history\n            - persistence (bool): Whether to persist memory\n\n    Raises:\n        ValueError: If required parameters are invalid\n        ConfigurationError: If configuration is invalid\n    \"\"\"\n</code></pre>"},{"location":"api/agent-model/#core-methods","title":"Core Methods","text":""},{"location":"api/agent-model/#state-management","title":"State Management","text":"<pre><code>async def a_update_inner_state(\n    self,\n    messages: List[dict],\n    sender: str,\n    **kwargs\n) -&gt; Tuple[bool, Optional[str]]:\n    \"\"\"\n    Update agent's inner state based on new messages.\n\n    Args:\n        messages: List of message dictionaries\n        sender: The agent or user who sent the messages\n        **kwargs: Additional keyword arguments\n\n    Returns:\n        Tuple containing:\n            - bool: Whether to generate a response\n            - Optional[str]: Generated response if any\n\n    Raises:\n        StateUpdateError: If state update fails\n    \"\"\"\n\nasync def update_system_message(self) -&gt; None:\n    \"\"\"\n    Update agent's system message based on current state.\n\n    This method should be called after significant state changes\n    to ensure the agent's behavior remains consistent with its\n    current state and context.\n    \"\"\"\n</code></pre>"},{"location":"api/agent-model/#message-processing","title":"Message Processing","text":"<pre><code>async def process_message(\n    self,\n    message: dict,\n    context: dict = None\n) -&gt; Optional[str]:\n    \"\"\"\n    Process incoming message and generate response.\n\n    Args:\n        message: Message dictionary containing:\n            - text (str): Message text\n            - from_user (dict): Sender information\n            - chat (dict): Chat information\n        context: Additional context information\n\n    Returns:\n        Optional[str]: Generated response if any\n\n    Raises:\n        ProcessingError: If message processing fails\n    \"\"\"\n\nasync def analyze_message_context(\n    self,\n    message: dict\n) -&gt; dict:\n    \"\"\"\n    Analyze message context for better understanding.\n\n    Args:\n        message: Message to analyze\n\n    Returns:\n        dict: Context analysis containing:\n            - intent (str): Detected message intent\n            - sentiment (float): Message sentiment score\n            - entities (list): Detected entities\n            - topics (list): Detected topics\n    \"\"\"\n</code></pre>"},{"location":"api/agent-model/#memory-management","title":"Memory Management","text":"<pre><code>class Memory:\n    def __init__(self, config: dict):\n        \"\"\"\n        Initialize memory system.\n\n        Args:\n            config: Memory configuration containing:\n                - max_size (int): Maximum memory size\n                - ttl (int): Time-to-live for memories\n                - storage_path (str): Path for persistent storage\n        \"\"\"\n\n    async def add_memory(\n        self,\n        key: str,\n        value: Any,\n        ttl: int = None\n    ) -&gt; None:\n        \"\"\"\n        Add item to memory.\n\n        Args:\n            key: Memory identifier\n            value: Data to store\n            ttl: Optional custom time-to-live\n\n        Raises:\n            MemoryError: If storage fails\n        \"\"\"\n\n    async def get_memory(\n        self,\n        key: str\n    ) -&gt; Optional[Any]:\n        \"\"\"\n        Retrieve item from memory.\n\n        Args:\n            key: Memory identifier\n\n        Returns:\n            Optional[Any]: Stored value if found\n        \"\"\"\n\n    async def cleanup(self) -&gt; None:\n        \"\"\"\n        Remove expired memories and optimize storage.\n        \"\"\"\n</code></pre>"},{"location":"api/agent-model/#social-relations","title":"Social Relations","text":"<pre><code>class SocialRelations:\n    def __init__(self):\n        self.relations = {}\n\n    async def update_relation(\n        self,\n        user_id: str,\n        metrics: dict\n    ) -&gt; None:\n        \"\"\"\n        Update social relationship metrics.\n\n        Args:\n            user_id: User identifier\n            metrics: Relationship metrics containing:\n                - trust (float): Trust score\n                - familiarity (float): Familiarity level\n                - rapport (float): Rapport score\n        \"\"\"\n\n    async def get_relation(\n        self,\n        user_id: str\n    ) -&gt; dict:\n        \"\"\"\n        Get relationship metrics for user.\n\n        Args:\n            user_id: User identifier\n\n        Returns:\n            dict: Current relationship metrics\n        \"\"\"\n</code></pre>"},{"location":"api/agent-model/#emotion-module","title":"Emotion Module","text":"<pre><code>class EmotionModule:\n    def __init__(self):\n        self.current_emotion = \"neutral\"\n        self.emotion_history = []\n\n    async def process_emotion(\n        self,\n        message: dict\n    ) -&gt; str:\n        \"\"\"\n        Process message to determine emotional response.\n\n        Args:\n            message: Message to analyze\n\n        Returns:\n            str: Determined emotion\n        \"\"\"\n\n    async def get_emotional_state(self) -&gt; dict:\n        \"\"\"\n        Get current emotional state.\n\n        Returns:\n            dict: Emotional state containing:\n                - current (str): Current emotion\n                - intensity (float): Emotion intensity\n                - history (list): Recent emotion history\n        \"\"\"\n</code></pre>"},{"location":"api/agent-model/#usage-examples","title":"Usage Examples","text":""},{"location":"api/agent-model/#basic-agent-setup","title":"Basic Agent Setup","text":"<pre><code>from teleAgent.models.agent_model.user_groupagent import UserGroupAgent\n\n# Initialize agent\nagent = UserGroupAgent(\n    name=\"GroupAssistant\",\n    system_message=\"I am a helpful and friendly group chat assistant\",\n    llm_config={\n        \"model\": \"gpt-4\",\n        \"temperature\": 0.7\n    },\n    memory_config={\n        \"max_history\": 1000,\n        \"persistence\": True\n    }\n)\n\n# Process message\nresponse = await agent.process_message({\n    \"text\": \"Hello, how are you?\",\n    \"from_user\": {\"id\": \"123\", \"name\": \"User\"},\n    \"chat\": {\"id\": \"456\", \"type\": \"group\"}\n})\n</code></pre>"},{"location":"api/agent-model/#advanced-state-management","title":"Advanced State Management","text":"<pre><code># Update agent state\nstate_update = await agent.a_update_inner_state(\n    messages=[{\n        \"text\": \"Let's discuss the project\",\n        \"from_user\": {\"id\": \"123\", \"name\": \"User\"}\n    }],\n    sender=\"user\"\n)\n\nif state_update[0]:  # Should respond\n    response = state_update[1]\n    # Send response to chat\n</code></pre>"},{"location":"api/agent-model/#memory-usage","title":"Memory Usage","text":"<pre><code># Store conversation context\nawait agent.memory.add_memory(\n    key=\"conversation_123\",\n    value={\n        \"topic\": \"Project Discussion\",\n        \"participants\": [\"User1\", \"User2\"],\n        \"key_points\": [\"Deadline\", \"Budget\"]\n    },\n    ttl=3600  # 1 hour\n)\n\n# Retrieve context later\ncontext = await agent.memory.get_memory(\"conversation_123\")\n</code></pre>"},{"location":"api/agent-model/#error-handling","title":"Error Handling","text":"<pre><code>class AgentError(Exception):\n    \"\"\"Base exception for agent-related errors\"\"\"\n    pass\n\nclass StateError(AgentError):\n    \"\"\"Exception for state management errors\"\"\"\n    pass\n\nclass ProcessingError(AgentError):\n    \"\"\"Exception for message processing errors\"\"\"\n    pass\n\nclass MemoryError(AgentError):\n    \"\"\"Exception for memory-related errors\"\"\"\n    pass\n\ntry:\n    await agent.process_message(message)\nexcept StateError as e:\n    logger.error(f\"State error: {e}\")\n    # Implement state recovery\nexcept ProcessingError as e:\n    logger.error(f\"Processing error: {e}\")\n    # Fallback to safe response\nexcept AgentError as e:\n    logger.error(f\"Agent error: {e}\")\n    # Handle other errors\n</code></pre>"},{"location":"api/artwork-creation/","title":"Artwork Creation API Reference","text":"<p>Comprehensive documentation for the TeleAgent Artwork Creation system, which handles AI-powered artwork generation and management.</p>"},{"location":"api/artwork-creation/#artworkgenerator","title":"ArtworkGenerator","text":"<p>The main class for generating and managing AI-powered artwork.</p>"},{"location":"api/artwork-creation/#constructor","title":"Constructor","text":"<pre><code>def __init__(\n    self,\n    config: dict,\n    dalle_client: DalleClient = None,\n    storage_manager: StorageManager = None\n):\n    \"\"\"\n    Initialize ArtworkGenerator.\n\n    Args:\n        config (dict): Configuration containing:\n            - model_version (str): DALL-E model version\n            - image_size (str): Default image size (e.g., \"1024x1024\")\n            - quality (str): Image quality setting\n        dalle_client (DalleClient, optional): Custom DALL-E client\n        storage_manager (StorageManager, optional): Custom storage manager\n\n    Raises:\n        ValueError: If required configuration is missing\n        InitializationError: If services initialization fails\n    \"\"\"\n</code></pre>"},{"location":"api/artwork-creation/#core-methods","title":"Core Methods","text":""},{"location":"api/artwork-creation/#artwork-generation","title":"Artwork Generation","text":"<pre><code>async def generate_artwork(\n    self,\n    prompt: str,\n    style_config: dict = None,\n    generation_options: dict = None\n) -&gt; dict:\n    \"\"\"\n    Generate artwork using AI.\n\n    Args:\n        prompt: Text description for the artwork\n        style_config: Optional style configuration:\n            - artistic_style (str): Desired art style\n            - color_scheme (str): Preferred colors\n            - composition (str): Layout preferences\n        generation_options: Optional generation parameters:\n            - num_variations (int): Number of variations\n            - image_size (str): Custom size for this generation\n            - quality (str): Quality setting override\n\n    Returns:\n        dict: Generated artwork information:\n            - image_url (str): URL of generated image\n            - prompt_id (str): Unique prompt identifier\n            - generation_params (dict): Parameters used\n            - variations (list): URLs of variations if requested\n\n    Raises:\n        GenerationError: If artwork generation fails\n    \"\"\"\n\nasync def enhance_prompt(\n    self,\n    base_prompt: str,\n    enhancement_type: str = \"detailed\"\n) -&gt; str:\n    \"\"\"\n    Enhance artwork prompt for better results.\n\n    Args:\n        base_prompt: Original user prompt\n        enhancement_type: Type of enhancement:\n            - \"detailed\": Add technical details\n            - \"artistic\": Add artistic elements\n            - \"style\": Add style-specific terms\n\n    Returns:\n        str: Enhanced prompt\n    \"\"\"\n</code></pre>"},{"location":"api/artwork-creation/#style-management","title":"Style Management","text":"<pre><code>class StyleManager:\n    def __init__(self):\n        self.available_styles = {}\n\n    async def apply_style(\n        self,\n        prompt: str,\n        style_name: str\n    ) -&gt; str:\n        \"\"\"\n        Apply predefined style to prompt.\n\n        Args:\n            prompt: Original artwork prompt\n            style_name: Name of style to apply\n\n        Returns:\n            str: Modified prompt with style elements\n\n        Raises:\n            StyleError: If style is not found\n        \"\"\"\n\n    async def register_style(\n        self,\n        style_name: str,\n        style_elements: dict\n    ) -&gt; None:\n        \"\"\"\n        Register new artwork style.\n\n        Args:\n            style_name: Name for the style\n            style_elements: Style configuration:\n                - keywords (list): Style-specific keywords\n                - modifiers (list): Prompt modifiers\n                - composition (dict): Composition rules\n        \"\"\"\n</code></pre>"},{"location":"api/artwork-creation/#storage-management","title":"Storage Management","text":"<pre><code>class ArtworkStorage:\n    def __init__(self, storage_config: dict):\n        \"\"\"\n        Initialize artwork storage.\n\n        Args:\n            storage_config: Storage configuration:\n                - provider (str): Storage provider\n                - bucket (str): Storage bucket name\n                - path_prefix (str): Storage path prefix\n        \"\"\"\n\n    async def store_artwork(\n        self,\n        image_data: bytes,\n        metadata: dict\n    ) -&gt; str:\n        \"\"\"\n        Store generated artwork.\n\n        Args:\n            image_data: Raw image data\n            metadata: Image metadata:\n                - prompt (str): Generation prompt\n                - params (dict): Generation parameters\n                - timestamp (str): Creation time\n\n        Returns:\n            str: Storage URL for the artwork\n\n        Raises:\n            StorageError: If storage operation fails\n        \"\"\"\n\n    async def retrieve_artwork(\n        self,\n        artwork_id: str\n    ) -&gt; Tuple[bytes, dict]:\n        \"\"\"\n        Retrieve stored artwork.\n\n        Args:\n            artwork_id: Unique artwork identifier\n\n        Returns:\n            Tuple containing:\n                - bytes: Image data\n                - dict: Artwork metadata\n\n        Raises:\n            NotFoundError: If artwork is not found\n        \"\"\"\n</code></pre>"},{"location":"api/artwork-creation/#quality-control","title":"Quality Control","text":"<pre><code>class QualityChecker:\n    def __init__(self, criteria: dict = None):\n        self.criteria = criteria or DEFAULT_CRITERIA\n\n    async def check_quality(\n        self,\n        image_data: bytes,\n        prompt: str\n    ) -&gt; dict:\n        \"\"\"\n        Check artwork quality against criteria.\n\n        Args:\n            image_data: Generated image data\n            prompt: Original generation prompt\n\n        Returns:\n            dict: Quality check results:\n                - score (float): Overall quality score\n                - aspects (dict): Individual aspect scores\n                - recommendations (list): Improvement suggestions\n        \"\"\"\n</code></pre>"},{"location":"api/artwork-creation/#usage-examples","title":"Usage Examples","text":""},{"location":"api/artwork-creation/#basic-artwork-generation","title":"Basic Artwork Generation","text":"<pre><code>from teleAgent.artwork.generator import ArtworkGenerator\n\n# Initialize generator\ngenerator = ArtworkGenerator({\n    \"model_version\": \"dall-e-3\",\n    \"image_size\": \"1024x1024\",\n    \"quality\": \"standard\"\n})\n\n# Generate artwork\nartwork = await generator.generate_artwork(\n    prompt=\"A serene landscape with mountains at sunset\",\n    style_config={\n        \"artistic_style\": \"impressionist\",\n        \"color_scheme\": \"warm\",\n        \"composition\": \"rule_of_thirds\"\n    }\n)\n</code></pre>"},{"location":"api/artwork-creation/#style-application","title":"Style Application","text":"<pre><code># Register custom style\nawait generator.style_manager.register_style(\n    style_name=\"cyberpunk\",\n    style_elements={\n        \"keywords\": [\"neon\", \"futuristic\", \"urban\"],\n        \"modifiers\": [\"high contrast\", \"vibrant colors\"],\n        \"composition\": {\n            \"lighting\": \"dramatic\",\n            \"perspective\": \"dynamic\"\n        }\n    }\n)\n\n# Generate with custom style\nartwork = await generator.generate_artwork(\n    prompt=\"A city street at night\",\n    style_config={\"artistic_style\": \"cyberpunk\"}\n)\n</code></pre>"},{"location":"api/artwork-creation/#error-handling","title":"Error Handling","text":"<pre><code>class ArtworkError(Exception):\n    \"\"\"Base exception for artwork-related errors\"\"\"\n    pass\n\nclass GenerationError(ArtworkError):\n    \"\"\"Exception for generation failures\"\"\"\n    pass\n\nclass StyleError(ArtworkError):\n    \"\"\"Exception for style-related errors\"\"\"\n    pass\n\nclass StorageError(ArtworkError):\n    \"\"\"Exception for storage operations\"\"\"\n    pass\n\ntry:\n    artwork = await generator.generate_artwork(prompt, style_config)\nexcept GenerationError as e:\n    logger.error(f\"Generation failed: {e}\")\n    # Handle generation failure\nexcept StyleError as e:\n    logger.error(f\"Style error: {e}\")\n    # Handle style-related failure\nexcept ArtworkError as e:\n    logger.error(f\"Artwork operation failed: {e}\")\n    # Handle other errors\n</code></pre>"},{"location":"api/artwork-creation/#best-practices","title":"Best Practices","text":"<ol> <li> <p>Prompt Engineering    ```python    def optimize_prompt(prompt: str) -&gt; str:        \"\"\"Optimize prompt for better results\"\"\"        # Add detail markers        prompt = f\"Detailed view: {prompt}\"</p> <p># Add quality markers    prompt = f\"{prompt}, high quality, professional\"</p> <p># Add composition guidance    prompt = f\"{prompt}, well composed, balanced\"</p> <p>return prompt    ```</p> </li> <li> <p>Resource Management    ```python    from contextlib import asynccontextmanager</p> </li> </ol> <p>@asynccontextmanager    async def artwork_session():        \"\"\"Manage artwork generation resources\"\"\"        generator = ArtworkGenerator(config)        try:            yield generator        finally:            await generator.cleanup()    ```</p> <ol> <li>Batch Processing <code>python    async def batch_generate(        prompts: List[str],        batch_size: int = 5    ) -&gt; List[dict]:        \"\"\"Process multiple artwork generations\"\"\"        results = []        for batch in chunks(prompts, batch_size):            batch_results = await asyncio.gather(                *(generator.generate_artwork(prompt) for prompt in batch)            )            results.extend(batch_results)        return results</code> </li> </ol>"},{"location":"api/bargaining-system/","title":"Bargaining System API Reference","text":"<p>Comprehensive documentation for the TeleAgent Bargaining System, which handles automated price negotiations and deal-making.</p>"},{"location":"api/bargaining-system/#bargainingagent","title":"BargainingAgent","text":"<p>The main class for managing price negotiations and deal-making processes.</p>"},{"location":"api/bargaining-system/#constructor","title":"Constructor","text":"<pre><code>def __init__(\n    self,\n    config: dict,\n    price_oracle: PriceOracle = None,\n    deal_manager: DealManager = None\n):\n    \"\"\"\n    Initialize BargainingAgent.\n\n    Args:\n        config (dict): Configuration containing:\n            - min_price (float): Minimum acceptable price\n            - max_price (float): Maximum acceptable price\n            - negotiation_steps (int): Maximum negotiation rounds\n            - strategy (str): Negotiation strategy type\n        price_oracle (PriceOracle, optional): Custom price oracle\n        deal_manager (DealManager, optional): Custom deal manager\n\n    Raises:\n        ValueError: If configuration is invalid\n        InitializationError: If services initialization fails\n    \"\"\"\n</code></pre>"},{"location":"api/bargaining-system/#core-methods","title":"Core Methods","text":""},{"location":"api/bargaining-system/#negotiation-management","title":"Negotiation Management","text":"<pre><code>async def start_negotiation(\n    self,\n    item_id: str,\n    initial_price: float,\n    counterparty_id: str,\n    context: dict = None\n) -&gt; dict:\n    \"\"\"\n    Start a new price negotiation.\n\n    Args:\n        item_id: Identifier of item being negotiated\n        initial_price: Starting price point\n        counterparty_id: Identifier of negotiating party\n        context: Optional negotiation context:\n            - urgency (str): Negotiation urgency level\n            - market_data (dict): Current market information\n            - preferences (dict): Negotiation preferences\n\n    Returns:\n        dict: Negotiation session information:\n            - session_id (str): Unique negotiation ID\n            - initial_offer (float): Starting offer\n            - status (str): Current negotiation status\n\n    Raises:\n        NegotiationError: If negotiation cannot be started\n    \"\"\"\n\nasync def make_offer(\n    self,\n    session_id: str,\n    offer_amount: float,\n    justification: str = None\n) -&gt; dict:\n    \"\"\"\n    Make a price offer in negotiation.\n\n    Args:\n        session_id: Active negotiation session ID\n        offer_amount: Proposed price amount\n        justification: Optional reasoning for offer\n\n    Returns:\n        dict: Offer result containing:\n            - offer_id (str): Unique offer identifier\n            - status (str): Offer status\n            - counter_offer (float): Optional counter-offer\n\n    Raises:\n        OfferError: If offer is invalid\n    \"\"\"\n</code></pre>"},{"location":"api/bargaining-system/#price-analysis","title":"Price Analysis","text":"<pre><code>class PriceAnalyzer:\n    def __init__(self, market_data: dict = None):\n        \"\"\"\n        Initialize price analyzer.\n\n        Args:\n            market_data: Optional market data:\n                - historical_prices (list): Price history\n                - market_trends (dict): Trend indicators\n                - volatility (float): Price volatility\n        \"\"\"\n\n    async def analyze_offer(\n        self,\n        offer_amount: float,\n        context: dict\n    ) -&gt; dict:\n        \"\"\"\n        Analyze price offer fairness.\n\n        Args:\n            offer_amount: Proposed price\n            context: Market context\n\n        Returns:\n            dict: Analysis results:\n                - fairness_score (float): Offer fairness\n                - market_alignment (float): Market fit\n                - recommendations (list): Action suggestions\n        \"\"\"\n\n    async def suggest_counter_offer(\n        self,\n        current_offer: float,\n        negotiation_history: List[dict]\n    ) -&gt; float:\n        \"\"\"\n        Suggest counter-offer amount.\n\n        Args:\n            current_offer: Current offer amount\n            negotiation_history: Previous offers\n\n        Returns:\n            float: Suggested counter-offer amount\n        \"\"\"\n</code></pre>"},{"location":"api/bargaining-system/#deal-management","title":"Deal Management","text":"<pre><code>class DealManager:\n    def __init__(self, config: dict):\n        \"\"\"\n        Initialize deal manager.\n\n        Args:\n            config: Deal management configuration:\n                - approval_threshold (float): Auto-approval limit\n                - confirmation_required (bool): Need confirmation\n                - timeout (int): Deal timeout seconds\n        \"\"\"\n\n    async def create_deal(\n        self,\n        negotiation_id: str,\n        final_price: float,\n        terms: dict\n    ) -&gt; dict:\n        \"\"\"\n        Create a new deal from negotiation.\n\n        Args:\n            negotiation_id: Completed negotiation ID\n            final_price: Agreed price amount\n            terms: Deal terms and conditions\n\n        Returns:\n            dict: Created deal information:\n                - deal_id (str): Unique deal identifier\n                - status (str): Deal status\n                - execution_plan (dict): Deal execution steps\n\n        Raises:\n            DealCreationError: If deal creation fails\n        \"\"\"\n\n    async def execute_deal(\n        self,\n        deal_id: str\n    ) -&gt; dict:\n        \"\"\"\n        Execute finalized deal.\n\n        Args:\n            deal_id: Deal to execute\n\n        Returns:\n            dict: Execution results:\n                - transaction_id (str): Transaction identifier\n                - status (str): Execution status\n                - completion_time (str): Completion timestamp\n\n        Raises:\n            DealExecutionError: If execution fails\n        \"\"\"\n</code></pre>"},{"location":"api/bargaining-system/#strategy-management","title":"Strategy Management","text":"<pre><code>class NegotiationStrategy:\n    def __init__(self, strategy_type: str):\n        \"\"\"\n        Initialize negotiation strategy.\n\n        Args:\n            strategy_type: Strategy type:\n                - \"aggressive\": Quick deal focus\n                - \"balanced\": Balanced approach\n                - \"conservative\": Risk-averse approach\n        \"\"\"\n\n    async def evaluate_position(\n        self,\n        current_price: float,\n        negotiation_state: dict\n    ) -&gt; dict:\n        \"\"\"\n        Evaluate negotiation position.\n\n        Args:\n            current_price: Current offer price\n            negotiation_state: Current state\n\n        Returns:\n            dict: Position evaluation:\n                - strength (float): Position strength\n                - next_action (str): Suggested action\n                - price_range (tuple): Target range\n        \"\"\"\n</code></pre>"},{"location":"api/bargaining-system/#usage-examples","title":"Usage Examples","text":""},{"location":"api/bargaining-system/#basic-negotiation","title":"Basic Negotiation","text":"<pre><code>from teleAgent.bargaining.agent import BargainingAgent\n\n# Initialize agent\nagent = BargainingAgent({\n    \"min_price\": 100.0,\n    \"max_price\": 1000.0,\n    \"negotiation_steps\": 5,\n    \"strategy\": \"balanced\"\n})\n\n# Start negotiation\nnegotiation = await agent.start_negotiation(\n    item_id=\"nft_123\",\n    initial_price=500.0,\n    counterparty_id=\"user_456\",\n    context={\n        \"urgency\": \"medium\",\n        \"market_data\": {\"current_floor\": 450.0}\n    }\n)\n\n# Make offer\noffer_result = await agent.make_offer(\n    session_id=negotiation[\"session_id\"],\n    offer_amount=450.0,\n    justification=\"Market alignment adjustment\"\n)\n</code></pre>"},{"location":"api/bargaining-system/#deal-execution","title":"Deal Execution","text":"<pre><code># Create and execute deal\ndeal = await agent.deal_manager.create_deal(\n    negotiation_id=negotiation[\"session_id\"],\n    final_price=450.0,\n    terms={\n        \"payment_method\": \"crypto\",\n        \"delivery_time\": \"immediate\"\n    }\n)\n\nresult = await agent.deal_manager.execute_deal(\n    deal_id=deal[\"deal_id\"]\n)\n</code></pre>"},{"location":"api/bargaining-system/#error-handling","title":"Error Handling","text":"<pre><code>class BargainingError(Exception):\n    \"\"\"Base exception for bargaining-related errors\"\"\"\n    pass\n\nclass NegotiationError(BargainingError):\n    \"\"\"Exception for negotiation failures\"\"\"\n    pass\n\nclass OfferError(BargainingError):\n    \"\"\"Exception for offer-related errors\"\"\"\n    pass\n\nclass DealError(BargainingError):\n    \"\"\"Exception for deal-related errors\"\"\"\n    pass\n\ntry:\n    negotiation = await agent.start_negotiation(item_id, price, counterparty)\nexcept NegotiationError as e:\n    logger.error(f\"Negotiation failed: {e}\")\n    # Handle negotiation failure\nexcept OfferError as e:\n    logger.error(f\"Offer error: {e}\")\n    # Handle offer failure\nexcept BargainingError as e:\n    logger.error(f\"Bargaining operation failed: {e}\")\n    # Handle other errors\n</code></pre>"},{"location":"api/bargaining-system/#best-practices","title":"Best Practices","text":"<ol> <li> <p>Price Validation <code>python    def validate_price(price: float, context: dict) -&gt; bool:        \"\"\"Validate price against market conditions\"\"\"        if price &lt; context[\"market_floor\"]:            return False        if price &gt; context[\"market_ceiling\"]:            return False        return True</code></p> </li> <li> <p>Negotiation Timeout <code>python    async def negotiate_with_timeout(        agent: BargainingAgent,        timeout: int = 300    ):        \"\"\"Handle negotiation with timeout\"\"\"        async with timeout_scope(timeout):            try:                result = await agent.start_negotiation(...)                return result            except TimeoutError:                await agent.cancel_negotiation(...)                raise NegotiationTimeout(\"Negotiation timed out\")</code></p> </li> <li> <p>Deal Safety    ```python    async def safe_deal_execution(        deal_manager: DealManager,        deal_id: str    ) -&gt; dict:        \"\"\"Execute deal with safety checks\"\"\"        # Verify deal status        if not await deal_manager.verify_deal(deal_id):            raise DealError(\"Invalid deal\")</p> <p># Check counterparty    if not await deal_manager.verify_counterparty(deal_id):        raise DealError(\"Counterparty verification failed\")</p> <p># Execute with retry    return await retry_with_backoff(        deal_manager.execute_deal,        deal_id    )    ``` </p> </li> </ol>"},{"location":"api/nft-tools/","title":"NFT Tools API Reference","text":"<p>Comprehensive documentation for the TeleAgent NFT Tools system, which handles NFT creation, management, and transactions.</p>"},{"location":"api/nft-tools/#nftcreator","title":"NFTCreator","text":"<p>The main class for NFT creation and minting operations.</p>"},{"location":"api/nft-tools/#constructor","title":"Constructor","text":"<pre><code>def __init__(\n    self,\n    config: dict,\n    artwork_dao: ArtworkDAO = None,\n    nft_dao: NFTDAO = None\n):\n    \"\"\"\n    Initialize NFTCreator.\n\n    Args:\n        config (dict): Configuration containing:\n            - wallet_address (str): Creator's wallet address\n            - network (str): Blockchain network (e.g., \"mainnet\", \"devnet\")\n            - api_endpoint (str): RPC endpoint URL\n        artwork_dao (ArtworkDAO, optional): Data access object for artwork\n        nft_dao (NFTDAO, optional): Data access object for NFTs\n\n    Raises:\n        ValueError: If required configuration is missing\n        ConnectionError: If network connection fails\n    \"\"\"\n</code></pre>"},{"location":"api/nft-tools/#core-methods","title":"Core Methods","text":""},{"location":"api/nft-tools/#nft-creation","title":"NFT Creation","text":"<pre><code>async def create_nft(\n    self,\n    artwork: dict,\n    metadata: dict,\n    options: dict = None\n) -&gt; dict:\n    \"\"\"\n    Create a new NFT from artwork.\n\n    Args:\n        artwork: Artwork information containing:\n            - image_url (str): URL of the artwork\n            - title (str): Artwork title\n            - description (str): Artwork description\n        metadata: NFT metadata containing:\n            - attributes (list): NFT attributes\n            - properties (dict): Additional properties\n        options: Optional creation parameters:\n            - royalty_percentage (float): Creator royalty\n            - is_mutable (bool): Whether metadata can be updated\n\n    Returns:\n        dict: Created NFT information containing:\n            - mint_address (str): NFT mint address\n            - metadata_url (str): Metadata URL\n            - transaction_id (str): Creation transaction ID\n\n    Raises:\n        NFTCreationError: If NFT creation fails\n    \"\"\"\n\nasync def mint_nft(\n    self,\n    mint_address: str,\n    recipient_address: str = None\n) -&gt; dict:\n    \"\"\"\n    Mint an NFT to a recipient.\n\n    Args:\n        mint_address: NFT mint address\n        recipient_address: Optional recipient wallet address\n            (defaults to creator's address)\n\n    Returns:\n        dict: Minting result containing:\n            - transaction_id (str): Minting transaction ID\n            - recipient (str): Recipient wallet address\n\n    Raises:\n        MintingError: If minting operation fails\n    \"\"\"\n</code></pre>"},{"location":"api/nft-tools/#metadata-management","title":"Metadata Management","text":"<pre><code>class MetadataManager:\n    def __init__(self, storage_config: dict):\n        \"\"\"\n        Initialize metadata manager.\n\n        Args:\n            storage_config: Storage configuration containing:\n                - provider (str): Storage provider (e.g., \"arweave\", \"ipfs\")\n                - endpoint (str): Storage endpoint URL\n        \"\"\"\n\n    async def upload_metadata(\n        self,\n        metadata: dict,\n        is_mutable: bool = False\n    ) -&gt; str:\n        \"\"\"\n        Upload NFT metadata to storage.\n\n        Args:\n            metadata: NFT metadata\n            is_mutable: Whether metadata can be updated\n\n        Returns:\n            str: Metadata URL\n\n        Raises:\n            StorageError: If upload fails\n        \"\"\"\n\n    async def update_metadata(\n        self,\n        metadata_url: str,\n        updates: dict\n    ) -&gt; str:\n        \"\"\"\n        Update existing NFT metadata.\n\n        Args:\n            metadata_url: Current metadata URL\n            updates: Metadata updates to apply\n\n        Returns:\n            str: New metadata URL\n\n        Raises:\n            StorageError: If update fails\n            ImmutableError: If metadata is immutable\n        \"\"\"\n</code></pre>"},{"location":"api/nft-tools/#transaction-management","title":"Transaction Management","text":"<pre><code>class TransactionManager:\n    def __init__(self, network_config: dict):\n        self.client = AsyncClient(network_config[\"endpoint\"])\n\n    async def send_transaction(\n        self,\n        transaction: Transaction,\n        signers: List[Keypair]\n    ) -&gt; str:\n        \"\"\"\n        Send and confirm transaction.\n\n        Args:\n            transaction: Transaction to send\n            signers: Required transaction signers\n\n        Returns:\n            str: Transaction signature\n\n        Raises:\n            TransactionError: If transaction fails\n        \"\"\"\n\n    async def verify_transaction(\n        self,\n        signature: str\n    ) -&gt; dict:\n        \"\"\"\n        Verify transaction status.\n\n        Args:\n            signature: Transaction signature\n\n        Returns:\n            dict: Transaction status and details\n        \"\"\"\n</code></pre>"},{"location":"api/nft-tools/#nft-transfer","title":"NFT Transfer","text":"<pre><code>async def transfer_nft(\n    self,\n    mint_address: str,\n    recipient_address: str,\n    options: dict = None\n) -&gt; dict:\n    \"\"\"\n    Transfer NFT to new owner.\n\n    Args:\n        mint_address: NFT mint address\n        recipient_address: Recipient wallet address\n        options: Optional transfer parameters:\n            - skip_preflight (bool): Skip preflight check\n            - max_retries (int): Maximum retry attempts\n\n    Returns:\n        dict: Transfer result containing:\n            - transaction_id (str): Transfer transaction ID\n            - old_owner (str): Previous owner address\n            - new_owner (str): New owner address\n\n    Raises:\n        TransferError: If transfer fails\n    \"\"\"\n</code></pre>"},{"location":"api/nft-tools/#usage-examples","title":"Usage Examples","text":""},{"location":"api/nft-tools/#basic-nft-creation","title":"Basic NFT Creation","text":"<pre><code>from teleAgent.nft.creator import NFTCreator\n\n# Initialize creator\ncreator = NFTCreator({\n    \"wallet_address\": \"YOUR_WALLET_ADDRESS\",\n    \"network\": \"devnet\",\n    \"api_endpoint\": \"https://api.devnet.solana.com\"\n})\n\n# Create NFT\nnft = await creator.create_nft(\n    artwork={\n        \"image_url\": \"https://example.com/art.png\",\n        \"title\": \"My First NFT\",\n        \"description\": \"A beautiful artwork\"\n    },\n    metadata={\n        \"attributes\": [\n            {\"trait_type\": \"Background\", \"value\": \"Blue\"},\n            {\"trait_type\": \"Style\", \"value\": \"Abstract\"}\n        ],\n        \"properties\": {\n            \"files\": [{\"uri\": \"https://example.com/art.png\", \"type\": \"image/png\"}],\n            \"category\": \"image\"\n        }\n    }\n)\n</code></pre>"},{"location":"api/nft-tools/#nft-transfer_1","title":"NFT Transfer","text":"<pre><code># Transfer NFT\ntransfer_result = await creator.transfer_nft(\n    mint_address=\"NFT_MINT_ADDRESS\",\n    recipient_address=\"RECIPIENT_ADDRESS\",\n    options={\n        \"skip_preflight\": False,\n        \"max_retries\": 3\n    }\n)\n\n# Verify transfer\nstatus = await creator.transaction_manager.verify_transaction(\n    transfer_result[\"transaction_id\"]\n)\n</code></pre>"},{"location":"api/nft-tools/#error-handling","title":"Error Handling","text":"<pre><code>class NFTError(Exception):\n    \"\"\"Base exception for NFT-related errors\"\"\"\n    pass\n\nclass NFTCreationError(NFTError):\n    \"\"\"Exception for NFT creation failures\"\"\"\n    pass\n\nclass MintingError(NFTError):\n    \"\"\"Exception for minting failures\"\"\"\n    pass\n\nclass TransferError(NFTError):\n    \"\"\"Exception for transfer failures\"\"\"\n    pass\n\ntry:\n    nft = await creator.create_nft(artwork, metadata)\nexcept NFTCreationError as e:\n    logger.error(f\"Creation failed: {e}\")\n    # Handle creation failure\nexcept MintingError as e:\n    logger.error(f\"Minting failed: {e}\")\n    # Handle minting failure\nexcept NFTError as e:\n    logger.error(f\"NFT operation failed: {e}\")\n    # Handle other errors\n</code></pre>"},{"location":"api/nft-tools/#best-practices","title":"Best Practices","text":"<ol> <li> <p>Transaction Safety    ```python    async def safe_transfer(mint_address: str, recipient: str) -&gt; dict:        \"\"\"Implement safe transfer with verification\"\"\"        # Verify ownership        if not await verify_ownership(mint_address):            raise OwnershipError(\"Not the owner\")</p> <p># Check recipient account    if not await verify_recipient(recipient):        raise RecipientError(\"Invalid recipient\")</p> <p># Execute transfer    result = await transfer_nft(mint_address, recipient)</p> <p># Verify transfer    status = await verify_transaction(result[\"transaction_id\"])    if not status[\"success\"]:        raise TransferError(\"Transfer failed\")</p> <p>return result    ```</p> </li> <li> <p>Metadata Validation <code>python    def validate_metadata(metadata: dict) -&gt; bool:        \"\"\"Validate NFT metadata structure\"\"\"        required_fields = [\"name\", \"description\", \"image\"]        return all(field in metadata for field in required_fields)</code></p> </li> <li> <p>Rate Limiting    ```python    from teleAgent.utilities.rate_limiter import RateLimiter</p> </li> </ol> <p>rate_limiter = RateLimiter(        max_requests=10,  # Maximum requests per window        time_window=60    # Window size in seconds    )</p> <p>@rate_limiter.limit    async def create_nft(artwork: dict, metadata: dict):        # NFT creation logic        pass    ``` </p>"},{"location":"api/telegram/","title":"Telegram API Reference","text":"<p>Comprehensive documentation for the TeleAgent Telegram integration module.</p>"},{"location":"api/telegram/#telegramclient","title":"TelegramClient","text":"<p>The main class for interacting with Telegram's Bot API.</p>"},{"location":"api/telegram/#constructor","title":"Constructor","text":"<pre><code>def __init__(self, config: dict):\n    \"\"\"\n    Initialize TelegramClient.\n\n    Args:\n        config (dict): Configuration dictionary containing:\n            - bot_token (str): Telegram bot token\n            - api_id (str): Telegram API ID\n            - api_hash (str): Telegram API hash\n\n    Raises:\n        ValueError: If required config values are missing\n        TelegramError: If initialization fails\n    \"\"\"\n</code></pre>"},{"location":"api/telegram/#methods","title":"Methods","text":""},{"location":"api/telegram/#message-handling","title":"Message Handling","text":"<pre><code>async def on_message(self):\n    \"\"\"\n    Decorator for handling new messages.\n\n    Example:\n        @client.on_message()\n        async def handle_message(message):\n            await message.reply(\"Received your message!\")\n    \"\"\"\n\nasync def on_edited_message(self):\n    \"\"\"\n    Decorator for handling edited messages.\n\n    Example:\n        @client.on_edited_message()\n        async def handle_edit(message):\n            await message.reply(\"Message was edited!\")\n    \"\"\"\n\nasync def on_command(self, command: str):\n    \"\"\"\n    Decorator for handling bot commands.\n\n    Args:\n        command (str): Command name without '/'\n\n    Example:\n        @client.on_command(\"start\")\n        async def handle_start(message):\n            await message.reply(\"Bot started!\")\n    \"\"\"\n</code></pre>"},{"location":"api/telegram/#message-sending","title":"Message Sending","text":"<pre><code>async def send_message(\n    self,\n    chat_id: Union[int, str],\n    text: str,\n    parse_mode: str = None,\n    reply_markup: dict = None\n) -&gt; dict:\n    \"\"\"\n    Send text message to a chat.\n\n    Args:\n        chat_id: Unique identifier for the target chat\n        text: Message text\n        parse_mode: Text parsing mode (HTML/Markdown)\n        reply_markup: Additional interface options\n\n    Returns:\n        dict: Sent message information\n\n    Raises:\n        TelegramError: If message sending fails\n    \"\"\"\n\nasync def send_photo(\n    self,\n    chat_id: Union[int, str],\n    photo: Union[str, bytes],\n    caption: str = None,\n    reply_markup: dict = None\n) -&gt; dict:\n    \"\"\"\n    Send photo to a chat.\n\n    Args:\n        chat_id: Unique identifier for the target chat\n        photo: Photo to send (file_id, URL, or bytes)\n        caption: Photo caption\n        reply_markup: Additional interface options\n\n    Returns:\n        dict: Sent message information\n\n    Raises:\n        TelegramError: If photo sending fails\n    \"\"\"\n</code></pre>"},{"location":"api/telegram/#group-management","title":"Group Management","text":"<pre><code>async def get_chat_member(\n    self,\n    chat_id: Union[int, str],\n    user_id: int\n) -&gt; dict:\n    \"\"\"\n    Get information about a chat member.\n\n    Args:\n        chat_id: Unique identifier for the target chat\n        user_id: Unique identifier of the target user\n\n    Returns:\n        dict: Chat member information\n\n    Raises:\n        TelegramError: If request fails\n    \"\"\"\n\nasync def ban_chat_member(\n    self,\n    chat_id: Union[int, str],\n    user_id: int,\n    until_date: int = None\n) -&gt; bool:\n    \"\"\"\n    Ban a user in a group.\n\n    Args:\n        chat_id: Unique identifier for the target chat\n        user_id: Unique identifier of the user to ban\n        until_date: Ban duration in Unix time\n\n    Returns:\n        bool: True on success\n\n    Raises:\n        TelegramError: If ban fails\n    \"\"\"\n</code></pre>"},{"location":"api/telegram/#events","title":"Events","text":"<pre><code>async def on_new_chat_members(self):\n    \"\"\"\n    Decorator for handling new chat members.\n\n    Example:\n        @client.on_new_chat_members()\n        async def welcome(message):\n            for user in message.new_chat_members:\n                await message.reply(f\"Welcome {user.first_name}!\")\n    \"\"\"\n\nasync def on_left_chat_member(self):\n    \"\"\"\n    Decorator for handling members leaving chat.\n\n    Example:\n        @client.on_left_chat_member()\n        async def goodbye(message):\n            user = message.left_chat_member\n            await message.reply(f\"Goodbye {user.first_name}!\")\n    \"\"\"\n</code></pre>"},{"location":"api/telegram/#error-handling","title":"Error Handling","text":"<pre><code>class TelegramError(Exception):\n    \"\"\"Base exception for Telegram-related errors\"\"\"\n    pass\n\nclass APIError(TelegramError):\n    \"\"\"Exception for API request failures\"\"\"\n    pass\n\nclass AuthError(TelegramError):\n    \"\"\"Exception for authentication failures\"\"\"\n    pass\n\nclass NetworkError(TelegramError):\n    \"\"\"Exception for network-related failures\"\"\"\n    pass\n</code></pre>"},{"location":"api/telegram/#types","title":"Types","text":""},{"location":"api/telegram/#message","title":"Message","text":"<pre><code>class Message:\n    \"\"\"Represents a Telegram message\"\"\"\n\n    @property\n    def message_id(self) -&gt; int:\n        \"\"\"Unique message identifier\"\"\"\n\n    @property\n    def from_user(self) -&gt; User:\n        \"\"\"Sender of the message\"\"\"\n\n    @property\n    def chat(self) -&gt; Chat:\n        \"\"\"Chat the message belongs to\"\"\"\n\n    @property\n    def text(self) -&gt; Optional[str]:\n        \"\"\"Message text\"\"\"\n\n    @property\n    def photo(self) -&gt; Optional[List[PhotoSize]]:\n        \"\"\"Available photo sizes\"\"\"\n</code></pre>"},{"location":"api/telegram/#user","title":"User","text":"<pre><code>class User:\n    \"\"\"Represents a Telegram user\"\"\"\n\n    @property\n    def id(self) -&gt; int:\n        \"\"\"Unique identifier for this user\"\"\"\n\n    @property\n    def first_name(self) -&gt; str:\n        \"\"\"User's first name\"\"\"\n\n    @property\n    def last_name(self) -&gt; Optional[str]:\n        \"\"\"User's last name\"\"\"\n\n    @property\n    def username(self) -&gt; Optional[str]:\n        \"\"\"User's username\"\"\"\n</code></pre>"},{"location":"api/telegram/#usage-examples","title":"Usage Examples","text":""},{"location":"api/telegram/#basic-bot-setup","title":"Basic Bot Setup","text":"<pre><code>from teleAgent.integrations.telegram import TelegramClient\n\nasync def main():\n    # Initialize client\n    client = TelegramClient({\n        \"bot_token\": \"YOUR_BOT_TOKEN\",\n        \"api_id\": \"YOUR_API_ID\",\n        \"api_hash\": \"YOUR_API_HASH\"\n    })\n\n    # Register message handler\n    @client.on_message()\n    async def echo(message):\n        await client.send_message(\n            chat_id=message.chat.id,\n            text=message.text\n        )\n\n    # Start the bot\n    await client.start()\n    await client.run_forever()\n</code></pre>"},{"location":"api/telegram/#command-handling","title":"Command Handling","text":"<pre><code># Register command handler\n@client.on_command(\"start\")\nasync def start_command(message):\n    await client.send_message(\n        chat_id=message.chat.id,\n        text=\"Welcome to the bot!\",\n        reply_markup={\n            \"inline_keyboard\": [\n                [{\n                    \"text\": \"Help\",\n                    \"callback_data\": \"help\"\n                }]\n            ]\n        }\n    )\n</code></pre>"},{"location":"api/telegram/#error-handling_1","title":"Error Handling","text":"<pre><code>try:\n    await client.send_message(chat_id, text)\nexcept APIError as e:\n    logger.error(f\"API Error: {e}\")\n    # Implement retry logic\nexcept NetworkError as e:\n    logger.error(f\"Network Error: {e}\")\n    # Wait and retry\nexcept TelegramError as e:\n    logger.error(f\"Telegram Error: {e}\")\n    # Handle other errors\n</code></pre>"},{"location":"modules/artwork-creation/","title":"Artwork Creation System","text":"<p>The Artwork Creation System is responsible for generating AI-powered artwork based on chat interactions and NFT requirements.</p>"},{"location":"modules/artwork-creation/#system-architecture","title":"System Architecture","text":"<pre><code>graph TB\n    subgraph Artwork Creation System\n        CA[Creative Artist Agent]\n        AC[Artwork Critic]\n        DD[DALL-E Drawer]\n    end\n\n    subgraph External Services\n        LLM[GPT-4]\n        DALLE[DALL-E API]\n        IPFS[IPFS Storage]\n    end\n\n    subgraph Input Sources\n        Chat[Chat History]\n        NFT[NFT Metadata]\n        Style[Style Preferences]\n    end\n\n    Chat --&gt; CA\n    NFT --&gt; CA\n    Style --&gt; CA\n\n    CA --&gt; AC\n    AC --&gt; DD\n    DD --&gt; DALLE\n    DD --&gt; IPFS\n\n    CA --&gt; LLM\n    AC --&gt; LLM\n</code></pre>"},{"location":"modules/artwork-creation/#core-components","title":"Core Components","text":""},{"location":"modules/artwork-creation/#creative-artist-agent","title":"Creative Artist Agent","text":"<pre><code>from teleAgent.models.agent_model.artwork_creation import CreativeArtistAgent\n\nartwork_creator = CreativeArtistAgent(\n    character_profile=profile,\n    dalle_config=dalle_config,\n    llm_config=llm_config,\n    wallet_address=wallet_address,\n    agent_id=agent_id\n)\n</code></pre>"},{"location":"modules/artwork-creation/#artwork-critic","title":"Artwork Critic","text":"<pre><code>class ArtworkCritic:\n    def __init__(self, llm_config: dict):\n        self.llm_config = llm_config\n\n    async def evaluate_artwork(self, artwork: dict) -&gt; dict:\n        \"\"\"\n        Evaluate generated artwork based on style, composition, and theme\n\n        Args:\n            artwork: Dictionary containing artwork data and metadata\n\n        Returns:\n            Dictionary containing evaluation results\n        \"\"\"\n        evaluation = await self._analyze_artwork(artwork)\n        suggestions = await self._generate_suggestions(evaluation)\n        return {\n            \"evaluation\": evaluation,\n            \"suggestions\": suggestions,\n            \"score\": self._calculate_score(evaluation)\n        }\n</code></pre>"},{"location":"modules/artwork-creation/#dall-e-integration","title":"DALL-E Integration","text":"<pre><code>class DalleDrawer:\n    def __init__(self, config: dict):\n        self.api_key = config[\"api_key\"]\n        self.model = config[\"model\"]\n        self.size = config.get(\"size\", \"1024x1024\")\n\n    async def generate_image(self, prompt: str) -&gt; dict:\n        \"\"\"\n        Generate image using DALL-E API\n\n        Args:\n            prompt: Detailed description for image generation\n\n        Returns:\n            Dictionary containing generated image data and metadata\n        \"\"\"\n        response = await openai.Image.create(\n            prompt=prompt,\n            n=1,\n            size=self.size,\n            model=self.model\n        )\n\n        return {\n            \"url\": response.data[0].url,\n            \"prompt\": prompt,\n            \"metadata\": self._extract_metadata(response)\n        }\n</code></pre>"},{"location":"modules/artwork-creation/#creation-workflow","title":"Creation Workflow","text":"<ol> <li> <p>Input Analysis <code>python    async def analyze_inputs(self, chat_history: list, nft_metadata: dict):        \"\"\"Analyze chat history and NFT metadata to extract creation parameters\"\"\"        style_elements = await self._extract_style_elements(chat_history)        theme = await self._determine_theme(nft_metadata)        return {            \"style\": style_elements,            \"theme\": theme,            \"color_scheme\": self._generate_color_scheme(style_elements)        }</code></p> </li> <li> <p>Prompt Generation <code>python    async def generate_prompt(self, analysis_result: dict):        \"\"\"Generate detailed prompt for DALL-E based on analysis\"\"\"        base_prompt = self._create_base_prompt(analysis_result[\"theme\"])        style_instructions = self._add_style_instructions(            analysis_result[\"style\"]        )        color_instructions = self._add_color_instructions(            analysis_result[\"color_scheme\"]        )        return f\"{base_prompt}\\n{style_instructions}\\n{color_instructions}\"</code></p> </li> <li> <p>Image Generation    ```python    async def create_artwork(self, prompt: str):        \"\"\"Generate artwork using DALL-E\"\"\"        try:            image_data = await self.dalle_drawer.generate_image(prompt)            evaluation = await self.critic.evaluate_artwork(image_data)</p> <pre><code>   if evaluation[\"score\"] &lt; self.quality_threshold:\n       return await self._regenerate_with_improvements(\n           prompt, \n           evaluation[\"suggestions\"]\n       )\n\n   return image_data\n</code></pre> <p>except Exception as e:        logger.error(f\"Artwork generation failed: {e}\")        raise ArtworkCreationError(str(e))    ```</p> </li> </ol>"},{"location":"modules/artwork-creation/#usage-examples","title":"Usage Examples","text":""},{"location":"modules/artwork-creation/#basic-artwork-creation","title":"Basic Artwork Creation","text":"<pre><code># Initialize the artwork creator\nartwork_creator = CreativeArtistAgent(config)\n\n# Generate artwork from chat history\nartwork = await artwork_creator.create_complete_artwork(messages)\nif artwork:\n    artwork['drawing'].save(\"generated_artwork.png\")\n</code></pre>"},{"location":"modules/artwork-creation/#advanced-usage-with-style-control","title":"Advanced Usage with Style Control","text":"<pre><code># Create artwork with specific style preferences\nstyle_config = {\n    \"artistic_style\": \"impressionist\",\n    \"color_palette\": \"warm\",\n    \"composition\": \"dynamic\",\n    \"mood\": \"energetic\"\n}\n\nartwork = await artwork_creator.create_artwork_with_style(\n    messages,\n    style_config\n)\n</code></pre>"},{"location":"modules/artwork-creation/#storage-and-retrieval","title":"Storage and Retrieval","text":"<pre><code>async def store_artwork(artwork_data: dict):\n    \"\"\"Store artwork and metadata in IPFS\"\"\"\n    ipfs_client = IPFSClient(config[\"ipfs_endpoint\"])\n\n    # Store image\n    image_cid = await ipfs_client.add_file(artwork_data[\"image\"])\n\n    # Store metadata\n    metadata = {\n        \"image\": f\"ipfs://{image_cid}\",\n        \"prompt\": artwork_data[\"prompt\"],\n        \"style\": artwork_data[\"style\"],\n        \"creation_date\": datetime.now().isoformat(),\n        \"evaluation\": artwork_data[\"evaluation\"]\n    }\n\n    metadata_cid = await ipfs_client.add_json(metadata)\n    return {\n        \"image_cid\": image_cid,\n        \"metadata_cid\": metadata_cid\n    }\n</code></pre>"},{"location":"modules/artwork-creation/#error-handling","title":"Error Handling","text":"<pre><code>class ArtworkCreationError(Exception):\n    \"\"\"Base exception for artwork creation errors\"\"\"\n    pass\n\nasync def handle_creation_error(error: Exception):\n    \"\"\"Handle various artwork creation errors\"\"\"\n    if isinstance(error, DalleAPIError):\n        return await fallback_generation_strategy()\n    elif isinstance(error, StorageError):\n        return await retry_storage_with_backoff()\n    elif isinstance(error, ValidationError):\n        return await regenerate_with_fixes()\n    raise ArtworkCreationError(f\"Unhandled error: {str(error)}\")\n</code></pre>"},{"location":"modules/artwork-creation/#best-practices","title":"Best Practices","text":"<ol> <li>Quality Control</li> <li>Implement thorough artwork evaluation</li> <li>Use multiple generation attempts if needed</li> <li> <p>Maintain style consistency</p> </li> <li> <p>Resource Management</p> </li> <li>Cache frequently used elements</li> <li>Implement rate limiting</li> <li> <p>Monitor API usage</p> </li> <li> <p>Storage Strategy</p> </li> <li>Use distributed storage (IPFS)</li> <li>Maintain metadata relationships</li> <li> <p>Implement backup mechanisms</p> </li> <li> <p>Error Recovery</p> </li> <li>Implement graceful fallbacks</li> <li>Maintain partial results</li> <li>Provide clear error messages </li> </ol>"},{"location":"modules/bargaining/","title":"Bargaining System","text":"<p>The Bargaining System enables automated price negotiations for NFT transactions.</p>"},{"location":"modules/bargaining/#architecture-overview","title":"Architecture Overview","text":"<pre><code>graph TB\n    subgraph Bargaining System\n        BA[Bargainer Agent]\n        DM[Deal Maker]\n        AC[Artwork Checker]\n    end\n\n    subgraph External Systems\n        NFT[NFT Service]\n        Price[Price Oracle]\n        User[User Interface]\n    end\n\n    User --&gt; BA\n    BA --&gt; DM\n    BA --&gt; AC\n    AC --&gt; NFT\n    AC --&gt; Price\n    DM --&gt; User\n</code></pre>"},{"location":"modules/bargaining/#components","title":"Components","text":""},{"location":"modules/bargaining/#bargainer-agent","title":"Bargainer Agent","text":"<pre><code>from teleAgent.models.agent_model.bargain.bargainer import BargainerAgent\n\nasync def create_bargainer(agent_id: str, nft_dao: NFTDAO):\n    bargainer = BargainerAgent(\n        agent_id=agent_id,\n        nft_dao=nft_dao\n    )\n    return bargainer\n</code></pre>"},{"location":"modules/bargaining/#deal-maker","title":"Deal Maker","text":"<pre><code>deal_maker = AssistantAgent(\n    name=\"Deal_Maker\",\n    system_message=\"\"\"\n    Monitor negotiations and confirm deals when agreement is reached.\n    Send \"CONGRATULATIONS! YOU HAVE MADE A DEAL! TERMINATE\" on success.\n    Otherwise, send \"CONTINUE\".\n    \"\"\",\n    llm_config=llm_config\n)\n</code></pre>"},{"location":"modules/bargaining/#artwork-checker","title":"Artwork Checker","text":"<pre><code>class ArtworkTools:\n    @staticmethod\n    def list_artwork() -&gt; Dict[str, str]:\n        \"\"\"List all available artwork\"\"\"\n        return {\n            \"NFT\": \"Digital artwork description\",\n            \"painting\": \"Physical artwork description\"\n        }\n\n    @staticmethod\n    def estimate_artwork_price(artwork: str) -&gt; str:\n        \"\"\"Estimate artwork price\"\"\"\n        return f\"The estimated price is $100,000\"\n</code></pre>"},{"location":"modules/bargaining/#negotiation-flow","title":"Negotiation Flow","text":"<ol> <li> <p>Initialization <code>python    async def start_negotiation(context: Dict[str, Any]):        agent_ls = create_bargain_group_chat(            agent_id='123',            nft_dao=nft_dao        )</code></p> </li> <li> <p>Price Discovery <code>python    async def determine_price(artwork_id: str):        price = await artwork_checker.estimate_artwork_price(artwork_id)        return adjust_price_range(price)</code></p> </li> <li> <p>Negotiation Process <code>python    async def negotiate(agent_ls, context):        while True:            result = await single_round_response(                agent_ls,                 context,                 chat_history            )            if is_deal_reached(result):                return finalize_deal(result)</code></p> </li> </ol>"},{"location":"modules/bargaining/#usage-example","title":"Usage Example","text":"<pre><code>async def run_bargain_chat(\n    context: Dict[str, Any],\n    nft_dao: NFTDAO,\n    artwork_critique_dao: ArtworkCritiqueDAO,\n    agent_inner_state: Dict[str, Any]\n) -&gt; None:\n    agent_ls = create_bargain_group_chat(\n        agent_id='7728897257',\n        nft_dao=nft_dao,\n        artwork_critique_dao=artwork_critique_dao,\n        agent_inner_state=agent_inner_state\n    )\n\n    while True:\n        chat_result = await single_round_response(\n            agent_ls,\n            context,\n            corrected_chat_history\n        )\n\n        if chat_result.is_deal_reached:\n            break\n\n        corrected_chat_history.append({\n            'content': chat_result.response,\n            'role': 'assistant',\n            'name': 'Bargainer'\n        })\n</code></pre>"},{"location":"modules/bargaining/#best-practices","title":"Best Practices","text":"<ol> <li>Price Management</li> <li>Use reliable price oracles</li> <li>Implement price validation</li> <li> <p>Set reasonable price ranges</p> </li> <li> <p>Negotiation Strategy</p> </li> <li>Start with market price</li> <li>Allow reasonable negotiation range</li> <li> <p>Set clear termination conditions</p> </li> <li> <p>Transaction Safety</p> </li> <li>Verify funds availability</li> <li>Implement escrow mechanism</li> <li> <p>Confirm both parties' agreement</p> </li> <li> <p>Error Handling</p> </li> <li>Handle timeout scenarios</li> <li>Manage failed transactions</li> <li>Implement dispute resolution </li> </ol>"},{"location":"modules/proactive-group-agent/","title":"Agent Model System","text":"<p>This module implements a sophisticated agent system with cognitive capabilities, artwork creation, and bargaining abilities. The system is built with a modular architecture that allows for flexible extension and customization.</p>"},{"location":"modules/proactive-group-agent/#core-components","title":"Core Components","text":""},{"location":"modules/proactive-group-agent/#1-proactive-group-agent","title":"1. Proactive Group Agent","text":"<p>The <code>ProactGroupAgent</code> class extends <code>AssistantAgent</code> and implements a proactive agent that can: - Participate in group chats - Maintain emotional states - Process messages through cognitive modules - Generate contextual responses</p> <p>Key features: - Group chat management - Message history transformation - Inner state updates - Timestamp-based message tracking</p>"},{"location":"modules/proactive-group-agent/#2-inner-modules","title":"2. Inner Modules","text":""},{"location":"modules/proactive-group-agent/#core-inner-modules","title":"Core Inner Modules","text":"<p>Each module serves a specific cognitive function:</p> <pre><code>class ProactGroupAgent(AssistantAgent, Agent):\n    def __init__(self, *args, **kwargs):\n        # Initialize inner modules\n        self.emotion_module = EmotionModuleAgent()\n        self.social_module = SocialRelationshipModuleAgent()\n        self.thoughts_module = ThoughtsModuleAgent()\n        self.summary_module = SummaryModuleAgent()\n        self.reflection_module = ReflectInteractionModuleAgent()\n</code></pre>"},{"location":"modules/proactive-group-agent/#creating-custom-inner-modules","title":"Creating Custom Inner Modules","text":"<ol> <li>Create a new module class:</li> </ol> <pre><code>from teleAgent.models.agent_model.inner_modules.module_agent import CognitiveModuleAgent\n\nclass CustomModuleAgent(CognitiveModuleAgent):\n    def __init__(self, function_prompt=CustomPrompt, *args, **kwargs):\n        super().__init__(\n            name='custom_module',\n            system_message=\"Your module's system message\",\n            functional_prompt=function_prompt,\n            *args, **kwargs)\n        self.function_chain.add(self.process_message)\n\n    def process_message(self, message_dict, recipient):\n        # Implement module logic\n        return {\"processed_data\": message_dict}\n</code></pre> <ol> <li>Define module prompt:</li> </ol> <pre><code>from teleAgent.models.agent_model.prompts.base_prompt import BasePrompt\n\nclass CustomPrompt(BasePrompt):\n    def __init__(self):\n        super().__init__(prompt_type='custom')\n        self.recordable_key = ['key1', 'key2']\n        self.format_prompt = \"\"\"\n        Your prompt template here.\n        Expected output format:\n        {\n            \"key1\": \"value1\",\n            \"key2\": \"value2\"\n        }\n        \"\"\"\n</code></pre> <ol> <li>Integrate with ProactGroupAgent:</li> </ol> <pre><code>class ProactGroupAgent(AssistantAgent, Agent):\n    def __init__(self, *args, **kwargs):\n        # Add custom module\n        self.custom_module = CustomModuleAgent(\n            llm_config=self.llm_config\n        )\n        self.inner_modules.append(self.custom_module)\n</code></pre>"},{"location":"modules/proactive-group-agent/#module-processing-flow","title":"Module Processing Flow","text":"<ol> <li>Message Reception:</li> </ol> <pre><code>async def process_message(self, message):\n    for module in self.inner_modules:\n        processed = await module.process(message)\n        self.update_state(processed)\n</code></pre> <ol> <li>State Updates:</li> </ol> <pre><code>def update_state(self, module_output):\n    self.working_memory.update(module_output)\n    self.update_system_message()\n</code></pre>"},{"location":"modules/proactive-group-agent/#3-system-messages","title":"3. System Messages","text":"<p>The agent uses dynamic system messages that incorporate: - Agent profile - Personality traits - Art preferences - Current emotional state - Interaction patterns</p> <p>Example system message template:</p> <pre><code>PROFILE_MESSAGE = \"\"\"\n    You are {self.name}. {self.chat_situation_prompt}\n    Your personality is: {self.personality}\n    Your painting style is: {self.painting_style}\n    Your tone is: {self.tone}\n    Your art preference is: {self.art_preference}\n    Your current mood is: {self.emotion}\n\"\"\"\n</code></pre>"},{"location":"modules/proactive-group-agent/#usage","title":"Usage","text":"<p>For detailed usage instructions and examples, refer to individual module documentation and the example files in the project repository.</p>"},{"location":"modules/telegram/","title":"Telegram Integration","text":"<p>The Telegram integration module provides the core functionality for interacting with the Telegram Bot API.</p>"},{"location":"modules/telegram/#overview","title":"Overview","text":"<pre><code>from teleAgent.integrations.telegram import TelegramClient\n</code></pre> <p>The <code>TelegramClient</code> class handles all Telegram-related operations, including: - Message processing - User management - Group chat interactions - Media handling</p>"},{"location":"modules/telegram/#configuration","title":"Configuration","text":"<pre><code>telegram_config = {\n    \"bot_token\": \"YOUR_BOT_TOKEN\",\n    \"api_id\": \"YOUR_API_ID\",\n    \"api_hash\": \"YOUR_API_HASH\"\n}\n\nclient = TelegramClient(telegram_config)\n</code></pre>"},{"location":"modules/telegram/#key-components","title":"Key Components","text":""},{"location":"modules/telegram/#message-handler","title":"Message Handler","text":"<pre><code>@client.on_message()\nasync def handle_message(message):\n    \"\"\"\n    Process incoming Telegram messages\n    \"\"\"\n    # Message processing logic\n    pass\n</code></pre>"},{"location":"modules/telegram/#group-chat-management","title":"Group Chat Management","text":"<pre><code>async def manage_group_chat(chat_id: int):\n    \"\"\"\n    Handle group chat operations\n    \"\"\"\n    # Group management logic\n    pass\n</code></pre>"},{"location":"modules/telegram/#usage-examples","title":"Usage Examples","text":""},{"location":"modules/telegram/#basic-bot-setup","title":"Basic Bot Setup","text":"<pre><code>from teleAgent.integrations.telegram import TelegramClient\n\nasync def main():\n    client = TelegramClient(config)\n    await client.start()\n\n    @client.on_message()\n    async def echo(message):\n        await message.reply(message.text)\n\n    await client.run()\n</code></pre>"},{"location":"modules/telegram/#advanced-features","title":"Advanced Features","text":"<ul> <li>Message filtering</li> <li>Media handling</li> <li>Inline keyboards</li> <li>Callback queries</li> </ul>"},{"location":"modules/telegram/#error-handling","title":"Error Handling","text":"<pre><code>try:\n    await client.send_message(chat_id, text)\nexcept TelegramError as e:\n    logger.error(f\"Failed to send message: {e}\")\n</code></pre>"},{"location":"modules/telegram/#best-practices","title":"Best Practices","text":"<ol> <li>Always handle exceptions</li> <li>Use rate limiting</li> <li>Implement proper logging</li> <li>Follow Telegram Bot API guidelines </li> </ol>"},{"location":"modules/user-group-agent/","title":"User Group Agent","text":"<p>The User Group Agent module manages group interactions and user behavior in chat environments.</p>"},{"location":"modules/user-group-agent/#overview","title":"Overview","text":"<pre><code>from teleAgent.models.agent_model.user_groupagent import UserGroupAgent\n</code></pre> <p>The <code>UserGroupAgent</code> class extends the base agent functionality to handle group-specific behaviors and interactions.</p>"},{"location":"modules/user-group-agent/#core-components","title":"Core Components","text":""},{"location":"modules/user-group-agent/#state-management","title":"State Management","text":"<pre><code>class UserGroupAgent(ProactGroupAgent):\n    def __init__(self, name: str, system_message: str, **kwargs):\n        super().__init__(name=name, system_message=system_message, **kwargs)\n        self.working_memory = {}\n        self.long_term_memory = {}\n        self.social_relations = {}\n</code></pre>"},{"location":"modules/user-group-agent/#event-handling","title":"Event Handling","text":"<pre><code>async def a_update_inner_state(self, messages, sender, **kwargs):\n    \"\"\"\n    Update agent's inner state based on new messages\n\n    Args:\n        messages: List of message dictionaries\n        sender: The agent or user who sent the messages\n    \"\"\"\n    if self.working_memory.get('fast_reply', 0):\n        self.working_memory.update({'response_decision': 0})\n        return (False, None)\n\n    message = self.transform_message_history(messages, sender)\n    self.update_message_to_modules(message)\n    reply = await self.a_initiate_chats(self.module_sequence)\n    self.update_system_message()\n</code></pre>"},{"location":"modules/user-group-agent/#social-interaction-management","title":"Social Interaction Management","text":"<pre><code>def update_social_relations(self, user_id: str, interaction_data: dict):\n    \"\"\"\n    Update social relationship data for a specific user\n\n    Args:\n        user_id: Unique identifier for the user\n        interaction_data: Dictionary containing interaction metrics\n    \"\"\"\n    if user_id not in self.social_relations:\n        self.social_relations[user_id] = {}\n\n    self.social_relations[user_id].update(interaction_data)\n</code></pre>"},{"location":"modules/user-group-agent/#integration-examples","title":"Integration Examples","text":""},{"location":"modules/user-group-agent/#basic-group-chat-setup","title":"Basic Group Chat Setup","text":"<pre><code>async def setup_group_chat():\n    agent = UserGroupAgent(\n        name=\"GroupManager\",\n        system_message=\"I am a helpful group chat manager\",\n        llm_config={\"model\": \"gpt-4\"}\n    )\n\n    # Add event handlers\n    @agent.on_user_join\n    async def welcome_user(user):\n        await agent.send_message(\n            f\"Welcome {user.name} to the group!\"\n        )\n\n    return agent\n</code></pre>"},{"location":"modules/user-group-agent/#advanced-usage","title":"Advanced Usage","text":"<pre><code># Implementing complex group behaviors\nasync def manage_group_dynamics():\n    agent = UserGroupAgent(...)\n\n    # Monitor and moderate discussions\n    @agent.on_message\n    async def moderate_content(message):\n        analysis = await agent.analyze_message(message)\n        if analysis.requires_moderation:\n            await agent.moderate_message(message)\n\n    # Track user engagement\n    @agent.on_interaction\n    async def track_engagement(interaction):\n        await agent.update_user_metrics(\n            interaction.user_id,\n            interaction.metrics\n        )\n</code></pre>"},{"location":"modules/user-group-agent/#best-practices","title":"Best Practices","text":"<ol> <li>State Management</li> <li>Regularly persist important state data</li> <li>Implement state recovery mechanisms</li> <li> <p>Clear temporary states periodically</p> </li> <li> <p>Memory Management</p> </li> <li>Use working memory for short-term context</li> <li>Persist important information to long-term memory</li> <li> <p>Implement memory cleanup routines</p> </li> <li> <p>Social Relations</p> </li> <li>Track user interactions</li> <li>Update relationship metrics</li> <li> <p>Use relationship data for personalized responses</p> </li> <li> <p>Error Handling</p> </li> <li>Implement graceful fallbacks</li> <li>Log errors appropriately</li> <li>Maintain group stability during errors</li> </ol>"},{"location":"modules/user-group-agent/#configuration","title":"Configuration","text":"<pre><code>agent_config = {\n    \"name\": \"GroupManager\",\n    \"personality\": \"helpful and friendly\",\n    \"response_style\": \"casual\",\n    \"memory_config\": {\n        \"max_working_memory\": 1000,\n        \"persistence_path\": \"/path/to/storage\"\n    },\n    \"moderation_rules\": {\n        \"max_messages_per_minute\": 10,\n        \"forbidden_words\": [\"spam\", \"abuse\"],\n        \"action_thresholds\": {\n            \"warning\": 2,\n            \"mute\": 3,\n            \"ban\": 5\n        }\n    }\n}\n</code></pre>"},{"location":"tutorials/artwork-creation/","title":"Artwork Creation Guide","text":"<p>This tutorial will guide you through implementing AI-powered artwork creation using TeleAgent's artwork generation system.</p>"},{"location":"tutorials/artwork-creation/#overview","title":"Overview","text":"<p>We'll create a system that: 1. Generates AI artwork using DALL-E 2. Implements artwork critique and refinement 3. Manages artwork storage and retrieval 4. Handles style customization 5. Provides quality control</p>"},{"location":"tutorials/artwork-creation/#prerequisites","title":"Prerequisites","text":"<ul> <li>Completed Basic Bot Setup</li> <li>OpenAI API key for DALL-E</li> <li>IPFS or similar storage solution</li> <li>Basic understanding of image generation</li> </ul>"},{"location":"tutorials/artwork-creation/#project-structure","title":"Project Structure","text":"<pre><code>artwork_system/\n\u251c\u2500\u2500 generators/\n\u2502   \u251c\u2500\u2500 artist.py\n\u2502   \u251c\u2500\u2500 critic.py\n\u2502   \u2514\u2500\u2500 dalle_client.py\n\u251c\u2500\u2500 storage/\n\u2502   \u251c\u2500\u2500 ipfs_storage.py\n\u2502   \u2514\u2500\u2500 metadata.py\n\u251c\u2500\u2500 styles/\n\u2502   \u251c\u2500\u2500 style_manager.py\n\u2502   \u2514\u2500\u2500 templates.py\n\u2514\u2500\u2500 main.py\n</code></pre>"},{"location":"tutorials/artwork-creation/#step-1-creative-artist-setup","title":"Step 1: Creative Artist Setup","text":"<pre><code># generators/artist.py\nfrom teleAgent.models.agent_model.artwork_creation import CreativeArtistAgent\nfrom teleAgent.models.agent_model.artwork_creation.dalle_draw import DalleDrawer\n\nclass ArtworkCreator:\n    def __init__(self, config: dict):\n        self.artist = CreativeArtistAgent(\n            character_profile=config[\"profile\"],\n            dalle_config=config[\"dalle\"],\n            llm_config=config[\"llm\"]\n        )\n        self.drawer = DalleDrawer(config[\"dalle\"])\n\n    async def create_artwork(self, prompt: str, style: dict = None) -&gt; dict:\n        \"\"\"Generate artwork from prompt with optional style\"\"\"\n        try:\n            # Enhance prompt with artistic elements\n            enhanced_prompt = await self.artist.enhance_prompt(\n                prompt,\n                style=style\n            )\n\n            # Generate initial image\n            artwork = await self.drawer.generate_image(enhanced_prompt)\n\n            # Get artwork critique\n            critique = await self.artist.critique_artwork(artwork)\n\n            # Refine if needed\n            if critique[\"score\"] &lt; 0.8:\n                artwork = await self._refine_artwork(\n                    artwork,\n                    critique[\"suggestions\"]\n                )\n\n            return {\n                \"image_url\": artwork[\"url\"],\n                \"prompt\": enhanced_prompt,\n                \"metadata\": artwork[\"metadata\"],\n                \"critique\": critique\n            }\n        except Exception as e:\n            logger.error(f\"Artwork creation failed: {e}\")\n            raise\n</code></pre>"},{"location":"tutorials/artwork-creation/#step-2-artwork-critic-implementation","title":"Step 2: Artwork Critic Implementation","text":"<pre><code># generators/critic.py\nclass ArtworkCritic:\n    def __init__(self, config: dict):\n        self.llm_config = config[\"llm\"]\n        self.quality_threshold = config[\"quality_threshold\"]\n\n    async def evaluate_artwork(self, artwork: dict) -&gt; dict:\n        \"\"\"Evaluate artwork quality and provide feedback\"\"\"\n        try:\n            # Analyze composition\n            composition_score = await self._analyze_composition(artwork)\n\n            # Analyze style consistency\n            style_score = await self._analyze_style(artwork)\n\n            # Analyze technical quality\n            technical_score = await self._analyze_technical_quality(artwork)\n\n            # Calculate overall score\n            overall_score = (\n                composition_score * 0.4 +\n                style_score * 0.3 +\n                technical_score * 0.3\n            )\n\n            # Generate improvement suggestions\n            suggestions = await self._generate_suggestions(\n                artwork,\n                {\n                    \"composition\": composition_score,\n                    \"style\": style_score,\n                    \"technical\": technical_score\n                }\n            )\n\n            return {\n                \"score\": overall_score,\n                \"composition_score\": composition_score,\n                \"style_score\": style_score,\n                \"technical_score\": technical_score,\n                \"suggestions\": suggestions\n            }\n        except Exception as e:\n            logger.error(f\"Artwork evaluation failed: {e}\")\n            raise\n</code></pre>"},{"location":"tutorials/artwork-creation/#step-3-style-management","title":"Step 3: Style Management","text":"<pre><code># styles/style_manager.py\nclass StyleManager:\n    def __init__(self):\n        self.available_styles = {\n            \"impressionist\": {\n                \"brush_strokes\": \"visible, loose\",\n                \"color_palette\": \"vibrant\",\n                \"lighting\": \"natural, outdoor\"\n            },\n            \"minimalist\": {\n                \"composition\": \"simple, clean\",\n                \"color_palette\": \"limited\",\n                \"details\": \"essential only\"\n            },\n            \"fantasy\": {\n                \"elements\": \"magical, surreal\",\n                \"color_palette\": \"ethereal\",\n                \"atmosphere\": \"mystical\"\n            }\n        }\n\n    async def apply_style(self, prompt: str, style_name: str) -&gt; str:\n        \"\"\"Apply selected style to prompt\"\"\"\n        if style_name not in self.available_styles:\n            raise ValueError(f\"Unknown style: {style_name}\")\n\n        style = self.available_styles[style_name]\n\n        # Enhance prompt with style elements\n        enhanced_prompt = f\"{prompt}, in {style_name} style, \"\n        enhanced_prompt += f\"with {style['brush_strokes']} brush strokes, \"\n        enhanced_prompt += f\"using a {style['color_palette']} color palette\"\n\n        return enhanced_prompt\n</code></pre>"},{"location":"tutorials/artwork-creation/#step-4-storage-implementation","title":"Step 4: Storage Implementation","text":"<pre><code># storage/ipfs_storage.py\nfrom ipfs_client import IPFSClient\n\nclass ArtworkStorage:\n    def __init__(self, config: dict):\n        self.ipfs = IPFSClient(config[\"ipfs_endpoint\"])\n        self.metadata_store = {}\n\n    async def store_artwork(self, artwork: dict) -&gt; str:\n        \"\"\"Store artwork and metadata in IPFS\"\"\"\n        try:\n            # Store image\n            image_cid = await self.ipfs.add_file(artwork[\"image\"])\n\n            # Prepare metadata\n            metadata = {\n                \"title\": artwork.get(\"title\", \"Untitled\"),\n                \"description\": artwork[\"prompt\"],\n                \"image\": f\"ipfs://{image_cid}\",\n                \"attributes\": {\n                    \"style\": artwork.get(\"style\", \"default\"),\n                    \"creation_date\": datetime.now().isoformat(),\n                    \"critique_score\": artwork[\"critique\"][\"score\"]\n                }\n            }\n\n            # Store metadata\n            metadata_cid = await self.ipfs.add_json(metadata)\n\n            # Update local store\n            self.metadata_store[metadata_cid] = metadata\n\n            return {\n                \"image_cid\": image_cid,\n                \"metadata_cid\": metadata_cid\n            }\n        except Exception as e:\n            logger.error(f\"Storage failed: {e}\")\n            raise\n</code></pre>"},{"location":"tutorials/artwork-creation/#step-5-command-implementation","title":"Step 5: Command Implementation","text":"<pre><code># main.py\nclass ArtworkCommands:\n    def __init__(self, client: TelegramClient):\n        self.client = client\n        self.creator = ArtworkCreator(config)\n        self.storage = ArtworkStorage(config)\n        self.style_manager = StyleManager()\n\n    async def setup_handlers(self):\n        @self.client.on_command(\"create_artwork\")\n        async def handle_create_artwork(message):\n            try:\n                # Parse command\n                args = message.text.split(maxsplit=2)\n                if len(args) &lt; 2:\n                    raise ValueError(\n                        \"Usage: /create_artwork [style] &lt;prompt&gt;\"\n                    )\n\n                style = args[1] if len(args) == 3 else \"default\"\n                prompt = args[-1]\n\n                # Send processing message\n                status_message = await self.client.send_message(\n                    chat_id=message.chat.id,\n                    text=\"\ud83c\udfa8 Creating your artwork...\"\n                )\n\n                # Generate artwork\n                artwork = await self.creator.create_artwork(\n                    prompt,\n                    style=style\n                )\n\n                # Store artwork\n                storage_info = await self.storage.store_artwork(artwork)\n\n                # Send result\n                await self.client.send_photo(\n                    chat_id=message.chat.id,\n                    photo=artwork[\"image_url\"],\n                    caption=(\n                        f\"\u2728 Artwork created!\\n\"\n                        f\"Style: {style}\\n\"\n                        f\"Quality score: {artwork['critique']['score']:.2f}\\n\"\n                        f\"IPFS: ipfs://{storage_info['image_cid']}\"\n                    )\n                )\n\n            except Exception as e:\n                await self.client.send_message(\n                    chat_id=message.chat.id,\n                    text=f\"\u274c Failed to create artwork: {str(e)}\"\n                )\n</code></pre>"},{"location":"tutorials/artwork-creation/#best-practices","title":"Best Practices","text":"<ol> <li> <p>Quality Control    ```python    async def ensure_quality(artwork: dict) -&gt; bool:        \"\"\"Verify artwork meets quality standards\"\"\"        # Check resolution        if not meets_resolution_requirements(artwork[\"image\"]):            return False</p> <p># Check style consistency    if not verify_style_consistency(artwork):        return False</p> <p># Check content safety    if not verify_content_safety(artwork):        return False</p> <p>return True    ```</p> </li> <li> <p>Resource Management    ```python    class ResourceManager:        def init(self):            self.api_calls = 0            self.last_reset = time.time()</p> <p>async def check_resources(self):        \"\"\"Check and manage API usage\"\"\"        # Reset counter if needed        if time.time() - self.last_reset &gt;= 3600:            self.api_calls = 0            self.last_reset = time.time()</p> <pre><code>   # Check limits\n   if self.api_calls &gt;= MAX_API_CALLS:\n       raise ResourceLimitError(\"API call limit reached\")\n\n   self.api_calls += 1\n</code></pre> <p>```</p> </li> <li> <p>Error Recovery <code>python    async def handle_generation_error(error: Exception, context: dict):        \"\"\"Handle artwork generation errors\"\"\"        if isinstance(error, APIError):            # Retry with different parameters            return await retry_with_fallback(context)        elif isinstance(error, QualityError):            # Try regenerating with enhanced prompt            return await regenerate_with_improvements(context)        else:            raise</code></p> </li> </ol>"},{"location":"tutorials/artwork-creation/#testing","title":"Testing","text":"<pre><code># test_artwork.py\n@pytest.mark.asyncio\nasync def test_artwork_creation():\n    # Setup\n    creator = ArtworkCreator(test_config)\n\n    # Test basic creation\n    artwork = await creator.create_artwork(\n        \"A serene mountain landscape\"\n    )\n    assert artwork[\"critique\"][\"score\"] &gt;= 0.8\n\n    # Test style application\n    styled_artwork = await creator.create_artwork(\n        \"A serene mountain landscape\",\n        style=\"impressionist\"\n    )\n    assert \"impressionist\" in styled_artwork[\"prompt\"].lower()\n</code></pre>"},{"location":"tutorials/artwork-creation/#troubleshooting","title":"Troubleshooting","text":"<ol> <li>Generation Issues</li> <li>Check API key validity</li> <li>Verify prompt formatting</li> <li> <p>Monitor rate limits</p> </li> <li> <p>Quality Issues</p> </li> <li>Review critique scores</li> <li>Check style consistency</li> <li> <p>Verify image resolution</p> </li> <li> <p>Storage Issues</p> </li> <li>Check IPFS connection</li> <li>Verify metadata format</li> <li>Monitor storage space</li> </ol>"},{"location":"tutorials/artwork-creation/#next-steps","title":"Next Steps","text":"<ol> <li>Implement advanced features:</li> <li>Style transfer</li> <li>Image editing</li> <li> <p>Animation support</p> </li> <li> <p>Add enhancement options:</p> </li> <li>Resolution upscaling</li> <li>Color correction</li> <li> <p>Detail enhancement</p> </li> <li> <p>Explore integrations:</p> </li> <li>Social media sharing</li> <li>NFT creation</li> <li>Print-on-demand services </li> </ol>"},{"location":"tutorials/bargaining-system/","title":"Bargaining System Tutorial","text":"<p>This tutorial will guide you through implementing the TeleAgent Bargaining System for automated NFT price negotiations.</p>"},{"location":"tutorials/bargaining-system/#overview","title":"Overview","text":"<p>We'll create a system that: 1. Implements automated price negotiations 2. Handles multi-party bargaining 3. Integrates with NFT pricing data 4. Manages deal completion 5. Provides transaction security</p>"},{"location":"tutorials/bargaining-system/#prerequisites","title":"Prerequisites","text":"<ul> <li>Completed Basic Bot Setup</li> <li>Understanding of NFT Creation</li> <li>Basic knowledge of price negotiation concepts</li> </ul>"},{"location":"tutorials/bargaining-system/#project-structure","title":"Project Structure","text":"<pre><code>bargaining_system/\n\u251c\u2500\u2500 agents/\n\u2502   \u251c\u2500\u2500 bargainer.py\n\u2502   \u251c\u2500\u2500 deal_maker.py\n\u2502   \u2514\u2500\u2500 price_advisor.py\n\u251c\u2500\u2500 models/\n\u2502   \u251c\u2500\u2500 negotiation.py\n\u2502   \u2514\u2500\u2500 deal.py\n\u251c\u2500\u2500 services/\n\u2502   \u251c\u2500\u2500 price_oracle.py\n\u2502   \u2514\u2500\u2500 escrow.py\n\u2514\u2500\u2500 main.py\n</code></pre>"},{"location":"tutorials/bargaining-system/#step-1-bargaining-agent-setup","title":"Step 1: Bargaining Agent Setup","text":"<pre><code># agents/bargainer.py\nfrom teleAgent.models.agent_model.bargain.bargainer import BargainerAgent\nfrom teleAgent.models.agent_model.utilities.bargain_utils import PriceRange\n\nclass NFTBargainer:\n    def __init__(self, config: dict):\n        self.agent = BargainerAgent(\n            agent_id=config[\"agent_id\"],\n            nft_dao=config[\"nft_dao\"],\n            llm_config=config[\"llm\"]\n        )\n        self.price_range = PriceRange(\n            min_price=config[\"min_price\"],\n            max_price=config[\"max_price\"]\n        )\n\n    async def start_negotiation(self, context: dict) -&gt; dict:\n        \"\"\"Start a new negotiation session\"\"\"\n        try:\n            # Initialize negotiation\n            session = await self.agent.create_session(\n                context=context,\n                price_range=self.price_range\n            )\n\n            # Set initial offer\n            initial_offer = await self._calculate_initial_offer(context)\n            await session.set_initial_offer(initial_offer)\n\n            return {\n                \"session_id\": session.id,\n                \"initial_offer\": initial_offer,\n                \"status\": \"started\"\n            }\n        except Exception as e:\n            logger.error(f\"Failed to start negotiation: {e}\")\n            raise\n</code></pre>"},{"location":"tutorials/bargaining-system/#step-2-deal-maker-implementation","title":"Step 2: Deal Maker Implementation","text":"<pre><code># agents/deal_maker.py\nclass DealMaker:\n    def __init__(self, config: dict):\n        self.min_profit = config[\"min_profit\"]\n        self.max_rounds = config[\"max_rounds\"]\n\n    async def evaluate_offer(self, offer: dict, context: dict) -&gt; bool:\n        \"\"\"Evaluate if an offer should be accepted\"\"\"\n        # Check market conditions\n        market_price = await self._get_market_price(offer[\"nft_id\"])\n\n        # Calculate potential profit\n        potential_profit = self._calculate_profit(\n            offer[\"price\"],\n            market_price\n        )\n\n        # Check if offer meets criteria\n        if potential_profit &gt;= self.min_profit:\n            return True\n\n        # Consider negotiation history\n        if context[\"round\"] &gt;= self.max_rounds:\n            return potential_profit &gt; 0\n\n        return False\n\n    async def finalize_deal(self, session_id: str) -&gt; dict:\n        \"\"\"Finalize a successful negotiation\"\"\"\n        try:\n            # Get session details\n            session = await self._get_session(session_id)\n\n            # Create deal\n            deal = await self._create_deal(session)\n\n            # Initialize escrow\n            await self._setup_escrow(deal)\n\n            return {\n                \"deal_id\": deal.id,\n                \"status\": \"finalized\",\n                \"terms\": deal.terms\n            }\n        except Exception as e:\n            logger.error(f\"Failed to finalize deal: {e}\")\n            raise\n</code></pre>"},{"location":"tutorials/bargaining-system/#step-3-price-oracle-integration","title":"Step 3: Price Oracle Integration","text":"<pre><code># services/price_oracle.py\nclass NFTPriceOracle:\n    def __init__(self, config: dict):\n        self.data_sources = config[\"data_sources\"]\n        self.cache_duration = config[\"cache_duration\"]\n        self._price_cache = {}\n\n    async def get_price_estimate(self, nft_id: str) -&gt; float:\n        \"\"\"Get estimated price for NFT\"\"\"\n        # Check cache\n        if self._is_cache_valid(nft_id):\n            return self._price_cache[nft_id][\"price\"]\n\n        # Fetch prices from multiple sources\n        prices = await self._fetch_prices(nft_id)\n\n        # Calculate weighted average\n        estimated_price = self._calculate_weighted_price(prices)\n\n        # Update cache\n        self._update_cache(nft_id, estimated_price)\n\n        return estimated_price\n\n    async def _fetch_prices(self, nft_id: str) -&gt; list:\n        \"\"\"Fetch prices from configured data sources\"\"\"\n        prices = []\n        for source in self.data_sources:\n            try:\n                price = await source.get_price(nft_id)\n                prices.append({\n                    \"price\": price,\n                    \"weight\": source.reliability\n                })\n            except Exception as e:\n                logger.warning(f\"Failed to fetch price from {source}: {e}\")\n        return prices\n</code></pre>"},{"location":"tutorials/bargaining-system/#step-4-negotiation-flow-implementation","title":"Step 4: Negotiation Flow Implementation","text":"<pre><code># models/negotiation.py\nclass NegotiationSession:\n    def __init__(self, config: dict):\n        self.id = str(uuid.uuid4())\n        self.buyer = config[\"buyer\"]\n        self.seller = config[\"seller\"]\n        self.nft_id = config[\"nft_id\"]\n        self.status = \"active\"\n        self.rounds = []\n        self.current_offer = None\n\n    async def make_offer(self, offer: float, party: str) -&gt; dict:\n        \"\"\"Record a new offer in the negotiation\"\"\"\n        self.rounds.append({\n            \"round\": len(self.rounds) + 1,\n            \"party\": party,\n            \"offer\": offer,\n            \"timestamp\": datetime.now()\n        })\n\n        self.current_offer = offer\n        return {\n            \"status\": \"offer_made\",\n            \"round\": len(self.rounds),\n            \"offer\": offer\n        }\n\n    async def accept_offer(self) -&gt; dict:\n        \"\"\"Accept the current offer\"\"\"\n        self.status = \"accepted\"\n        return {\n            \"status\": \"accepted\",\n            \"final_price\": self.current_offer,\n            \"rounds\": len(self.rounds)\n        }\n\n    async def reject_offer(self, reason: str = None) -&gt; dict:\n        \"\"\"Reject the current offer\"\"\"\n        self.status = \"rejected\"\n        return {\n            \"status\": \"rejected\",\n            \"reason\": reason,\n            \"rounds\": len(self.rounds)\n        }\n</code></pre>"},{"location":"tutorials/bargaining-system/#step-5-command-implementation","title":"Step 5: Command Implementation","text":"<pre><code># main.py\nclass BargainingCommands:\n    def __init__(self, client: TelegramClient):\n        self.client = client\n        self.bargainer = NFTBargainer(config)\n        self.deal_maker = DealMaker(config)\n\n    async def setup_handlers(self):\n        @self.client.on_command(\"start_bargain\")\n        async def handle_start_bargain(message):\n            try:\n                # Parse NFT ID and initial price\n                nft_id = message.text.split()[1]\n\n                # Start negotiation\n                result = await self.bargainer.start_negotiation({\n                    \"nft_id\": nft_id,\n                    \"user_id\": message.from_user.id\n                })\n\n                # Send confirmation\n                await self.client.send_message(\n                    chat_id=message.chat.id,\n                    text=f\"\ud83e\udd1d Negotiation started!\\n\"\n                         f\"Initial offer: {result['initial_offer']} SOL\\n\"\n                         f\"Use /make_offer &lt;amount&gt; to negotiate\"\n                )\n\n            except Exception as e:\n                await self.client.send_message(\n                    chat_id=message.chat.id,\n                    text=f\"\u274c Failed to start bargaining: {str(e)}\"\n                )\n\n        @self.client.on_command(\"make_offer\")\n        async def handle_make_offer(message):\n            try:\n                # Parse offer amount\n                amount = float(message.text.split()[1])\n\n                # Process offer\n                result = await self.bargainer.process_offer(\n                    session_id=get_active_session(message.from_user.id),\n                    amount=amount\n                )\n\n                # Check if deal can be made\n                if await self.deal_maker.evaluate_offer(result, {\n                    \"round\": result[\"round\"]\n                }):\n                    # Finalize deal\n                    deal = await self.deal_maker.finalize_deal(\n                        result[\"session_id\"]\n                    )\n\n                    await self.client.send_message(\n                        chat_id=message.chat.id,\n                        text=f\"\ud83c\udf89 Deal reached!\\n\"\n                             f\"Final price: {deal['terms']['price']} SOL\"\n                    )\n                else:\n                    # Continue negotiation\n                    counter_offer = await self.bargainer.generate_counter_offer(\n                        result\n                    )\n\n                    await self.client.send_message(\n                        chat_id=message.chat.id,\n                        text=f\"Counter offer: {counter_offer} SOL\"\n                    )\n\n            except Exception as e:\n                await self.client.send_message(\n                    chat_id=message.chat.id,\n                    text=f\"\u274c Failed to process offer: {str(e)}\"\n                )\n</code></pre>"},{"location":"tutorials/bargaining-system/#best-practices","title":"Best Practices","text":"<ol> <li> <p>Price Validation <code>python    def validate_price(price: float, context: dict) -&gt; bool:        \"\"\"Validate if price is within acceptable range\"\"\"        return (            price &gt;= context[\"min_price\"] and            price &lt;= context[\"max_price\"] and            price &gt; 0        )</code></p> </li> <li> <p>Transaction Security    ```python    async def secure_transaction(deal: dict):        \"\"\"Implement secure transaction handling\"\"\"        # Create escrow        escrow = await create_escrow_account(deal)</p> <p># Lock funds    await escrow.lock_funds(deal[\"price\"])</p> <p># Verify NFT ownership    await verify_nft_ownership(deal[\"nft_id\"], deal[\"seller\"])</p> <p># Execute transfer    return await execute_secure_transfer(escrow, deal)    ```</p> </li> <li> <p>State Management    ```python    class NegotiationState:        \"\"\"Manage negotiation state\"\"\"        def init(self):            self.active_sessions = {}            self.completed_deals = {}</p> <p>async def save_state(self):        \"\"\"Persist negotiation state\"\"\"        await database.save_sessions(self.active_sessions)        await database.save_deals(self.completed_deals)    ```</p> </li> </ol>"},{"location":"tutorials/bargaining-system/#testing","title":"Testing","text":"<pre><code># test_bargaining.py\n@pytest.mark.asyncio\nasync def test_negotiation_flow():\n    # Setup\n    bargainer = NFTBargainer(test_config)\n    deal_maker = DealMaker(test_config)\n\n    # Start negotiation\n    session = await bargainer.start_negotiation({\n        \"nft_id\": \"test_nft\",\n        \"initial_price\": 100\n    })\n\n    # Make offer\n    result = await bargainer.process_offer(\n        session[\"session_id\"],\n        90\n    )\n\n    # Verify result\n    assert result[\"status\"] == \"counter_offer\"\n    assert 80 &lt;= result[\"counter_offer\"] &lt;= 100\n</code></pre>"},{"location":"tutorials/bargaining-system/#troubleshooting","title":"Troubleshooting","text":"<ol> <li>Price Discrepancies</li> <li>Check price oracle data</li> <li>Verify calculation logic</li> <li> <p>Monitor market conditions</p> </li> <li> <p>Failed Negotiations</p> </li> <li>Review negotiation logs</li> <li>Check price thresholds</li> <li> <p>Verify user permissions</p> </li> <li> <p>Transaction Issues</p> </li> <li>Verify wallet balances</li> <li>Check network status</li> <li>Monitor gas prices</li> </ol>"},{"location":"tutorials/bargaining-system/#next-steps","title":"Next Steps","text":"<ol> <li>Implement advanced features:</li> <li>Multi-party negotiations</li> <li>Auction integration</li> <li> <p>Price prediction</p> </li> <li> <p>Add security features:</p> </li> <li>Fraud detection</li> <li>Dispute resolution</li> <li> <p>Insurance integration</p> </li> <li> <p>Explore other tutorials:</p> </li> <li>Artwork Creation </li> </ol>"},{"location":"tutorials/basic-bot/","title":"Basic Bot Setup Tutorial","text":"<p>This tutorial will guide you through creating a basic TeleAgent bot with essential features.</p>"},{"location":"tutorials/basic-bot/#overview","title":"Overview","text":"<p>We'll create a bot that can: 1. Respond to basic commands 2. Handle different types of messages 3. Manage group conversations 4. Implement basic memory and state management</p>"},{"location":"tutorials/basic-bot/#project-structure","title":"Project Structure","text":"<pre><code>my_bot/\n\u251c\u2500\u2500 config/\n\u2502   \u2514\u2500\u2500 config.py\n\u251c\u2500\u2500 handlers/\n\u2502   \u251c\u2500\u2500 __init__.py\n\u2502   \u251c\u2500\u2500 commands.py\n\u2502   \u251c\u2500\u2500 messages.py\n\u2502   \u2514\u2500\u2500 media.py\n\u251c\u2500\u2500 utils/\n\u2502   \u251c\u2500\u2500 __init__.py\n\u2502   \u2514\u2500\u2500 helpers.py\n\u251c\u2500\u2500 .env\n\u251c\u2500\u2500 requirements.txt\n\u2514\u2500\u2500 main.py\n</code></pre>"},{"location":"tutorials/basic-bot/#step-1-project-setup","title":"Step 1: Project Setup","text":"<ol> <li> <p>Create Project Directory <code>bash    mkdir my_bot    cd my_bot    python -m venv venv    source venv/bin/activate  # On Windows: venv\\Scripts\\activate</code></p> </li> <li> <p>Install Dependencies <code>bash    pip install teleAgent python-dotenv logging</code></p> </li> <li> <p>Create Requirements File <code>bash    pip freeze &gt; requirements.txt</code></p> </li> </ol>"},{"location":"tutorials/basic-bot/#step-2-configuration","title":"Step 2: Configuration","text":"<ol> <li> <p>Create <code>.env</code> File <code>env    TELEGRAM_BOT_TOKEN=your_bot_token    TELEGRAM_API_ID=your_api_id    TELEGRAM_API_HASH=your_api_hash    OPENAI_API_KEY=your_openai_key</code></p> </li> <li> <p>Create Configuration Module    ```python    # config/config.py    import os    from dotenv import load_dotenv</p> </li> </ol> <p>load_dotenv()</p> <p>class Config:        TELEGRAM_BOT_TOKEN = os.getenv(\"TELEGRAM_BOT_TOKEN\")        TELEGRAM_API_ID = os.getenv(\"TELEGRAM_API_ID\")        TELEGRAM_API_HASH = os.getenv(\"TELEGRAM_API_HASH\")        OPENAI_API_KEY = os.getenv(\"OPENAI_API_KEY\")</p> <pre><code>   # Bot Configuration\n   COMMAND_PREFIX = \"/\"\n   MAX_MESSAGE_LENGTH = 4096\n   RATE_LIMIT = 5  # messages per second\n</code></pre> <p>```</p>"},{"location":"tutorials/basic-bot/#step-3-command-handlers","title":"Step 3: Command Handlers","text":"<pre><code># handlers/commands.py\nfrom teleAgent.integrations.telegram import TelegramClient\nfrom teleAgent.models.agent_model.user_groupagent import UserGroupAgent\n\nclass CommandHandlers:\n    def __init__(self, client: TelegramClient, agent: UserGroupAgent):\n        self.client = client\n        self.agent = agent\n        self.setup_handlers()\n\n    def setup_handlers(self):\n        @self.client.on_command(\"start\")\n        async def start_command(message):\n            welcome_text = (\n                \"\ud83d\udc4b Hello! I'm your TeleAgent bot.\\n\"\n                \"Here are some commands you can use:\\n\"\n                \"/help - Show available commands\\n\"\n                \"/status - Check bot status\\n\"\n                \"/settings - Configure bot settings\"\n            )\n            await self.client.send_message(\n                chat_id=message.chat.id,\n                text=welcome_text\n            )\n\n        @self.client.on_command(\"help\")\n        async def help_command(message):\n            help_text = await self.agent.generate_help_text()\n            await self.client.send_message(\n                chat_id=message.chat.id,\n                text=help_text\n            )\n\n        @self.client.on_command(\"status\")\n        async def status_command(message):\n            status = await self.agent.get_status()\n            await self.client.send_message(\n                chat_id=message.chat.id,\n                text=f\"Bot Status:\\n{status}\"\n            )\n</code></pre>"},{"location":"tutorials/basic-bot/#step-4-message-handlers","title":"Step 4: Message Handlers","text":"<pre><code># handlers/messages.py\nfrom teleAgent.utilities.rate_limiter import RateLimiter\n\nclass MessageHandlers:\n    def __init__(self, client: TelegramClient, agent: UserGroupAgent):\n        self.client = client\n        self.agent = agent\n        self.rate_limiter = RateLimiter(max_requests=5, time_window=60)\n        self.setup_handlers()\n\n    def setup_handlers(self):\n        @self.client.on_message()\n        @self.rate_limiter.limit\n        async def handle_message(message):\n            # Process message with agent\n            response = await self.agent.process_message(message)\n\n            # Send response\n            if response:\n                await self.client.send_message(\n                    chat_id=message.chat.id,\n                    text=response\n                )\n\n        @self.client.on_edited_message()\n        async def handle_edited_message(message):\n            await self.agent.process_edited_message(message)\n</code></pre>"},{"location":"tutorials/basic-bot/#step-5-media-handlers","title":"Step 5: Media Handlers","text":"<pre><code># handlers/media.py\nclass MediaHandlers:\n    def __init__(self, client: TelegramClient, agent: UserGroupAgent):\n        self.client = client\n        self.agent = agent\n        self.setup_handlers()\n\n    def setup_handlers(self):\n        @self.client.on_photo()\n        async def handle_photo(message):\n            photo = await message.photo[-1].download()\n            caption = await self.agent.analyze_photo(photo)\n            await self.client.send_message(\n                chat_id=message.chat.id,\n                text=f\"Photo analysis: {caption}\"\n            )\n\n        @self.client.on_document()\n        async def handle_document(message):\n            doc_info = await self.agent.process_document(message.document)\n            await self.client.send_message(\n                chat_id=message.chat.id,\n                text=f\"Document info: {doc_info}\"\n            )\n</code></pre>"},{"location":"tutorials/basic-bot/#step-6-main-application","title":"Step 6: Main Application","text":"<pre><code># main.py\nimport asyncio\nimport logging\nfrom config.config import Config\nfrom teleAgent.integrations.telegram import TelegramClient\nfrom teleAgent.models.agent_model.user_groupagent import UserGroupAgent\nfrom handlers.commands import CommandHandlers\nfrom handlers.messages import MessageHandlers\nfrom handlers.media import MediaHandlers\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\nlogger = logging.getLogger(__name__)\n\nasync def main():\n    try:\n        # Initialize client\n        client = TelegramClient({\n            \"bot_token\": Config.TELEGRAM_BOT_TOKEN,\n            \"api_id\": Config.TELEGRAM_API_ID,\n            \"api_hash\": Config.TELEGRAM_API_HASH\n        })\n\n        # Initialize agent\n        agent = UserGroupAgent(\n            name=\"BasicBot\",\n            system_message=\"I am a helpful group chat assistant\",\n            llm_config={\"model\": \"gpt-4\"}\n        )\n\n        # Setup handlers\n        CommandHandlers(client, agent)\n        MessageHandlers(client, agent)\n        MediaHandlers(client, agent)\n\n        # Start the bot\n        logger.info(\"Starting bot...\")\n        await client.start()\n        await client.run_forever()\n\n    except Exception as e:\n        logger.error(f\"Bot crashed: {e}\")\n        raise\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n</code></pre>"},{"location":"tutorials/basic-bot/#step-7-running-the-bot","title":"Step 7: Running the Bot","text":"<ol> <li>Verify Configuration</li> <li>Check all environment variables are set</li> <li>Verify bot token with BotFather</li> <li> <p>Test API keys</p> </li> <li> <p>Start the Bot <code>bash    python main.py</code></p> </li> </ol>"},{"location":"tutorials/basic-bot/#best-practices","title":"Best Practices","text":"<ol> <li> <p>Error Handling <code>python    try:        await operation()    except TelegramError as e:        logger.error(f\"Telegram error: {e}\")        # Implement retry logic or fallback    except Exception as e:        logger.error(f\"Unexpected error: {e}\")        # Notify admin or take appropriate action</code></p> </li> <li> <p>Memory Management <code>python    # Implement cleanup routines    async def cleanup_old_messages():        while True:            await agent.cleanup_memory()            await asyncio.sleep(3600)  # Run every hour</code></p> </li> <li> <p>Performance Optimization    ```python    # Cache frequently used data    from functools import lru_cache</p> </li> </ol> <p>@lru_cache(maxsize=100)    async def get_user_preferences(user_id: int):        return await database.fetch_user_preferences(user_id)    ```</p>"},{"location":"tutorials/basic-bot/#testing","title":"Testing","text":"<pre><code># test_bot.py\nimport pytest\nfrom unittest.mock import AsyncMock, patch\n\n@pytest.mark.asyncio\nasync def test_start_command():\n    message = AsyncMock()\n    message.chat.id = 123456789\n\n    with patch('teleAgent.integrations.telegram.TelegramClient') as mock_client:\n        client = mock_client.return_value\n        await start_command(message)\n\n        client.send_message.assert_called_once_with(\n            chat_id=123456789,\n            text=\"\ud83d\udc4b Hello! I'm your TeleAgent bot.\"\n        )\n</code></pre>"},{"location":"tutorials/basic-bot/#next-steps","title":"Next Steps","text":"<ol> <li>Add more advanced features:</li> <li>Custom keyboards</li> <li>Inline queries</li> <li> <p>Callback queries</p> </li> <li> <p>Implement additional functionality:</p> </li> <li>User preferences</li> <li>Admin commands</li> <li> <p>Analytics tracking</p> </li> <li> <p>Explore other tutorials:</p> </li> <li>NFT Creation</li> <li>Group Chat Integration</li> <li>Bargaining System </li> </ol>"},{"location":"tutorials/getting-started/","title":"Getting Started with TeleAgent","text":"<p>This guide will help you set up and run your first TeleAgent instance.</p>"},{"location":"tutorials/getting-started/#prerequisites","title":"Prerequisites","text":"<p>Before you begin, ensure you have:</p> <ol> <li>Python 3.8 or higher installed</li> <li>A Telegram Bot Token (from @BotFather)</li> <li>OpenAI API Key (for GPT-4 and DALL-E)</li> <li>Basic knowledge of Python and async programming</li> </ol>"},{"location":"tutorials/getting-started/#installation","title":"Installation","text":"<ol> <li> <p>Clone the Repository <code>bash    git clone https://github.com/KingJiongEN/DegentGroup.git    cd DegentGroup</code></p> </li> <li> <p>Create a Virtual Environment <code>bash    python -m venv venv    source venv/bin/activate  # On Windows: venv\\Scripts\\activate</code></p> </li> <li> <p>Install Dependencies <code>bash    pip install -r requirements.txt</code></p> </li> </ol>"},{"location":"tutorials/getting-started/#configuration","title":"Configuration","text":"<ol> <li> <p>Create Environment File <code>bash    cp .env.example .env</code></p> </li> <li> <p>Configure Environment Variables    ```env    # Telegram Configuration    TELEGRAM_BOT_TOKEN=your_bot_token    TELEGRAM_API_ID=your_api_id    TELEGRAM_API_HASH=your_api_hash</p> </li> </ol> <p># OpenAI Configuration    OPENAI_API_KEY=your_openai_key</p> <p># Database Configuration    DATABASE_URL=sqlite:///./teleagent.db</p> <p># IPFS Configuration (Optional)    IPFS_NODE_URL=your_ipfs_node    ```</p>"},{"location":"tutorials/getting-started/#interesting-features","title":"Interesting Features","text":""},{"location":"tutorials/getting-started/#1-enable-nft-creation","title":"1. Enable NFT Creation","text":"<pre><code>from teleAgent.models.agent_model.artwork_creation import CreativeArtistAgent\n\n# Initialize the artwork creator\nartwork_creator = CreativeArtistAgent(\n    character_profile=\"creative and artistic\",\n    dalle_config={\"api_key\": \"YOUR_OPENAI_KEY\"},\n    llm_config={\"model\": \"gpt-4\"}\n)\n\n# Add artwork creation command\n@client.on_command(\"create_nft\")\nasync def create_nft(message):\n    # Generate artwork\n    artwork = await artwork_creator.create_artwork(message.text)\n\n    # Send the artwork\n    await client.send_photo(\n        chat_id=message.chat.id,\n        photo=artwork['url'],\n        caption=\"Here's your generated NFT!\"\n    )\n</code></pre>"},{"location":"tutorials/getting-started/#2-enable-bargaining","title":"2. Enable Bargaining","text":"<pre><code>from teleAgent.models.agent_model.bargain.bargainer import BargainerAgent\n\n# Initialize the bargainer\nbargainer = BargainerAgent(\n    agent_id=\"unique_id\",\n    nft_dao=your_nft_dao\n)\n\n# Add bargaining command\n@client.on_command(\"bargain\")\nasync def start_bargaining(message):\n    result = await bargainer.start_negotiation(\n        context={\"message\": message}\n    )\n    await client.send_message(\n        chat_id=message.chat.id,\n        text=f\"Bargaining result: {result}\"\n    )\n</code></pre>"},{"location":"tutorials/getting-started/#common-operations","title":"Common Operations","text":""},{"location":"tutorials/getting-started/#managing-group-chats","title":"Managing Group Chats","text":"<pre><code># Enable group management\n@client.on_new_chat_members()\nasync def welcome_new_members(message):\n    for user in message.new_chat_members:\n        await client.send_message(\n            chat_id=message.chat.id,\n            text=f\"Welcome {user.first_name} to the group!\"\n        )\n\n# Handle left members\n@client.on_left_chat_member()\nasync def goodbye_member(message):\n    user = message.left_chat_member\n    await client.send_message(\n        chat_id=message.chat.id,\n        text=f\"Goodbye {user.first_name}!\"\n    )\n</code></pre>"},{"location":"tutorials/getting-started/#handling-media","title":"Handling Media","text":"<pre><code># Handle images\n@client.on_photo()\nasync def process_photo(message):\n    # Download the photo\n    photo = await message.photo[-1].download()\n\n    # Process the photo\n    result = await process_image(photo)\n\n    await client.send_message(\n        chat_id=message.chat.id,\n        text=f\"Processed image result: {result}\"\n    )\n</code></pre>"},{"location":"tutorials/getting-started/#best-practices","title":"Best Practices","text":"<ol> <li> <p>Error Handling <code>python    try:        result = await some_operation()    except TelegramError as e:        logger.error(f\"Telegram error: {e}\")        await client.send_message(            chat_id=message.chat.id,            text=\"Sorry, something went wrong!\"        )    except Exception as e:        logger.error(f\"Unexpected error: {e}\")        await client.send_message(            chat_id=message.chat.id,            text=\"An unexpected error occurred\"        )</code></p> </li> <li> <p>Rate Limiting    ```python    from teleAgent.utilities.rate_limiter import RateLimiter</p> </li> </ol> <p>rate_limiter = RateLimiter(        max_requests=5,        time_window=60  # 1 minute    )</p> <p>@client.on_message()    @rate_limiter.limit    async def handle_message(message):        # Your handler code        pass    ```</p> <ol> <li>Logging    ```python    import logging</li> </ol> <p>logging.basicConfig(        level=logging.INFO,        format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'    )</p> <p>logger = logging.getLogger(name)    ```</p>"},{"location":"tutorials/getting-started/#troubleshooting","title":"Troubleshooting","text":""},{"location":"tutorials/getting-started/#common-issues","title":"Common Issues","text":"<ol> <li>Bot Not Responding</li> <li>Check if the bot token is correct</li> <li>Ensure the bot has the necessary permissions</li> <li> <p>Verify the internet connection</p> </li> <li> <p>API Errors</p> </li> <li>Check API key validity</li> <li>Verify rate limits</li> <li> <p>Check request formatting</p> </li> <li> <p>Database Issues</p> </li> <li>Verify database connection string</li> <li>Check database permissions</li> <li>Ensure tables are created properly</li> </ol>"},{"location":"tutorials/getting-started/#getting-help","title":"Getting Help","text":"<ul> <li>Check the GitHub Issues</li> <li>Join our Telegram Support Group</li> <li>Review the API documentation</li> </ul>"},{"location":"tutorials/getting-started/#next-steps","title":"Next Steps","text":"<ul> <li>Basic Bot Tutorial</li> <li>NFT Creation Tutorial</li> <li>Group Chat Integration</li> <li>API Reference </li> </ul>"},{"location":"tutorials/group-chat/","title":"Group Chat Integration Tutorial","text":"<p>This tutorial will guide you through implementing advanced group chat features using TeleAgent's User Group Agent.</p>"},{"location":"tutorials/group-chat/#overview","title":"Overview","text":"<p>We'll implement: 1. Advanced group chat management 2. Multi-user conversation handling 3. Role-based permissions 4. Group memory and context management 5. Proactive interactions</p>"},{"location":"tutorials/group-chat/#prerequisites","title":"Prerequisites","text":"<ul> <li>Completed Basic Bot Setup</li> <li>Understanding of TeleAgent's User Group Agent</li> <li>Basic knowledge of Telegram group features</li> </ul>"},{"location":"tutorials/group-chat/#project-structure","title":"Project Structure","text":"<pre><code>group_bot/\n\u251c\u2500\u2500 handlers/\n\u2502   \u251c\u2500\u2500 group_handler.py\n\u2502   \u251c\u2500\u2500 admin_handler.py\n\u2502   \u2514\u2500\u2500 memory_handler.py\n\u251c\u2500\u2500 models/\n\u2502   \u251c\u2500\u2500 group_state.py\n\u2502   \u2514\u2500\u2500 user_state.py\n\u251c\u2500\u2500 utils/\n\u2502   \u2514\u2500\u2500 permissions.py\n\u2514\u2500\u2500 main.py\n</code></pre>"},{"location":"tutorials/group-chat/#step-1-group-chat-setup","title":"Step 1: Group Chat Setup","text":"<pre><code># handlers/group_handler.py\nfrom teleAgent.models.agent_model.user_groupagent import UserGroupAgent\nfrom teleAgent.models.memory import GroupMemory\n\nclass GroupChatHandler:\n    def __init__(self, client: TelegramClient):\n        self.client = client\n        self.agent = UserGroupAgent(\n            name=\"GroupManager\",\n            system_message=\"I am a helpful group chat manager\",\n            memory_config={\n                \"max_history\": 1000,\n                \"persistence\": True\n            }\n        )\n        self.memory = GroupMemory()\n\n    async def setup(self):\n        @self.client.on_new_chat_members()\n        async def handle_new_members(message):\n            for user in message.new_chat_members:\n                await self._welcome_user(message.chat.id, user)\n                await self._update_group_state(message.chat.id, \"new_member\")\n\n        @self.client.on_left_chat_member()\n        async def handle_left_member(message):\n            await self._handle_member_left(\n                message.chat.id,\n                message.left_chat_member\n            )\n\n    async def _welcome_user(self, chat_id: int, user):\n        welcome_message = await self.agent.generate_welcome_message(user)\n        await self.client.send_message(\n            chat_id=chat_id,\n            text=welcome_message\n        )\n</code></pre>"},{"location":"tutorials/group-chat/#step-2-role-based-permissions","title":"Step 2: Role-Based Permissions","text":"<pre><code># utils/permissions.py\nfrom enum import Enum\nfrom functools import wraps\n\nclass UserRole(Enum):\n    ADMIN = \"admin\"\n    MODERATOR = \"moderator\"\n    MEMBER = \"member\"\n    GUEST = \"guest\"\n\nclass PermissionManager:\n    def __init__(self):\n        self.role_permissions = {\n            UserRole.ADMIN: {\"can_manage\", \"can_moderate\", \"can_post\"},\n            UserRole.MODERATOR: {\"can_moderate\", \"can_post\"},\n            UserRole.MEMBER: {\"can_post\"},\n            UserRole.GUEST: set()\n        }\n\n    def requires_permission(self, permission: str):\n        def decorator(func):\n            @wraps(func)\n            async def wrapper(message, *args, **kwargs):\n                user_role = await self.get_user_role(message.from_user.id)\n                if permission in self.role_permissions[user_role]:\n                    return await func(message, *args, **kwargs)\n                else:\n                    await message.reply(\n                        \"You don't have permission to perform this action.\"\n                    )\n            return wrapper\n        return decorator\n</code></pre>"},{"location":"tutorials/group-chat/#step-3-group-memory-management","title":"Step 3: Group Memory Management","text":"<pre><code># models/group_state.py\nfrom datetime import datetime\n\nclass GroupState:\n    def __init__(self, chat_id: int):\n        self.chat_id = chat_id\n        self.members = {}\n        self.conversation_history = []\n        self.active_topics = set()\n        self.last_activity = datetime.now()\n\n    async def update_conversation(self, message: dict):\n        \"\"\"Update conversation history and analyze context\"\"\"\n        self.conversation_history.append({\n            \"user_id\": message[\"from_user\"][\"id\"],\n            \"text\": message[\"text\"],\n            \"timestamp\": datetime.now(),\n            \"context\": await self._analyze_context(message)\n        })\n\n        # Cleanup old history if needed\n        if len(self.conversation_history) &gt; 1000:\n            self.conversation_history = self.conversation_history[-1000:]\n\n    async def _analyze_context(self, message: dict) -&gt; dict:\n        \"\"\"Analyze message context using the agent\"\"\"\n        return await self.agent.analyze_message_context(message)\n</code></pre>"},{"location":"tutorials/group-chat/#step-4-proactive-interactions","title":"Step 4: Proactive Interactions","text":"<pre><code># handlers/proactive_handler.py\nclass ProactiveHandler:\n    def __init__(self, client: TelegramClient, agent: UserGroupAgent):\n        self.client = client\n        self.agent = agent\n        self.cooldown = 300  # 5 minutes\n\n    async def setup(self):\n        # Schedule periodic checks\n        asyncio.create_task(self._periodic_check())\n\n    async def _periodic_check(self):\n        while True:\n            for group in self.agent.active_groups:\n                await self._check_group_activity(group)\n            await asyncio.sleep(self.cooldown)\n\n    async def _check_group_activity(self, group_id: int):\n        state = await self.agent.get_group_state(group_id)\n\n        # Check for inactive conversations\n        if await self._should_initiate_conversation(state):\n            topic = await self.agent.generate_topic(state)\n            await self.client.send_message(\n                chat_id=group_id,\n                text=f\"\ud83d\udcad {topic}\"\n            )\n</code></pre>"},{"location":"tutorials/group-chat/#step-5-advanced-message-handling","title":"Step 5: Advanced Message Handling","text":"<pre><code># handlers/message_handler.py\nclass MessageHandler:\n    def __init__(self, client: TelegramClient, agent: UserGroupAgent):\n        self.client = client\n        self.agent = agent\n\n    async def setup(self):\n        @self.client.on_message()\n        async def handle_message(message):\n            # Update group state\n            await self.agent.update_group_state(message)\n\n            # Check if should respond\n            if await self._should_respond(message):\n                response = await self.agent.generate_response(message)\n                await self.client.send_message(\n                    chat_id=message.chat.id,\n                    text=response\n                )\n\n    async def _should_respond(self, message) -&gt; bool:\n        \"\"\"Determine if the agent should respond to the message\"\"\"\n        # Check if message is directed to the bot\n        if message.reply_to_message and \\\n           message.reply_to_message.from_user.id == self.client.id:\n            return True\n\n        # Check if bot is mentioned\n        if f\"@{self.client.username}\" in message.text:\n            return True\n\n        # Use agent to determine if response is needed\n        return await self.agent.should_respond(message)\n</code></pre>"},{"location":"tutorials/group-chat/#step-6-main-application-integration","title":"Step 6: Main Application Integration","text":"<pre><code># main.py\nasync def main():\n    # Initialize client\n    client = TelegramClient(config)\n\n    # Initialize agent\n    agent = UserGroupAgent(\n        name=\"GroupManager\",\n        system_message=\"I am a helpful group chat manager\",\n        llm_config={\"model\": \"gpt-4\"}\n    )\n\n    # Setup handlers\n    group_handler = GroupChatHandler(client)\n    proactive_handler = ProactiveHandler(client, agent)\n    message_handler = MessageHandler(client, agent)\n\n    await group_handler.setup()\n    await proactive_handler.setup()\n    await message_handler.setup()\n\n    # Start the bot\n    await client.start()\n    await client.run_forever()\n</code></pre>"},{"location":"tutorials/group-chat/#best-practices","title":"Best Practices","text":"<ol> <li> <p>Memory Management <code>python    # Implement periodic cleanup    async def cleanup_old_data():        while True:            await agent.cleanup_memory()            await asyncio.sleep(3600)  # Every hour</code></p> </li> <li> <p>Rate Limiting <code>python    # Implement group-specific rate limits    rate_limiter = RateLimiter(        max_requests=5,        time_window=60,        per_chat=True    )</code></p> </li> <li> <p>Error Recovery <code>python    # Implement state recovery    async def recover_state():        try:            return await load_persisted_state()        except Exception:            return await create_new_state()</code></p> </li> </ol>"},{"location":"tutorials/group-chat/#testing","title":"Testing","text":"<pre><code># test_group_chat.py\n@pytest.mark.asyncio\nasync def test_group_chat_handling():\n    # Mock setup\n    client = AsyncMock()\n    agent = AsyncMock()\n\n    # Test message handling\n    handler = MessageHandler(client, agent)\n    message = create_test_message()\n    await handler.handle_message(message)\n\n    # Verify response\n    agent.generate_response.assert_called_once()\n</code></pre>"},{"location":"tutorials/group-chat/#troubleshooting","title":"Troubleshooting","text":"<ol> <li>Message Processing Issues</li> <li>Check message format</li> <li>Verify bot permissions</li> <li> <p>Monitor rate limits</p> </li> <li> <p>Memory Issues</p> </li> <li>Monitor memory usage</li> <li>Implement cleanup routines</li> <li> <p>Use persistent storage</p> </li> <li> <p>Performance Issues</p> </li> <li>Implement caching</li> <li>Use batch processing</li> <li>Optimize database queries</li> </ol>"},{"location":"tutorials/group-chat/#next-steps","title":"Next Steps","text":"<ol> <li>Add advanced features:</li> <li>Voice message handling</li> <li>Poll management</li> <li> <p>Event scheduling</p> </li> <li> <p>Implement analytics:</p> </li> <li>User engagement metrics</li> <li>Response quality tracking</li> <li> <p>Performance monitoring</p> </li> <li> <p>Explore other tutorials:</p> </li> <li>Bargaining System</li> <li>Artwork Creation </li> </ol>"},{"location":"tutorials/nft-creation/","title":"NFT Creation Tutorial","text":"<p>This tutorial will guide you through implementing NFT creation functionality in your TeleAgent bot.</p>"},{"location":"tutorials/nft-creation/#overview","title":"Overview","text":"<p>We'll create a system that can: 1. Generate AI artwork using DALL-E 2. Create NFTs from the artwork 3. Handle NFT metadata 4. Implement minting process 5. Enable NFT transfers</p>"},{"location":"tutorials/nft-creation/#prerequisites","title":"Prerequisites","text":"<ul> <li>Completed Basic Bot Setup</li> <li>OpenAI API key for DALL-E</li> <li>Solana wallet setup</li> <li>IPFS node access (optional)</li> </ul>"},{"location":"tutorials/nft-creation/#project-structure","title":"Project Structure","text":"<pre><code>nft_bot/\n\u251c\u2500\u2500 artwork/\n\u2502   \u251c\u2500\u2500 generator.py\n\u2502   \u2514\u2500\u2500 storage.py\n\u251c\u2500\u2500 nft/\n\u2502   \u251c\u2500\u2500 metadata.py\n\u2502   \u251c\u2500\u2500 minter.py\n\u2502   \u2514\u2500\u2500 transfer.py\n\u251c\u2500\u2500 config/\n\u2502   \u2514\u2500\u2500 config.py\n\u2514\u2500\u2500 main.py\n</code></pre>"},{"location":"tutorials/nft-creation/#step-1-artwork-generation-setup","title":"Step 1: Artwork Generation Setup","text":"<pre><code># artwork/generator.py\nfrom teleAgent.models.agent_model.artwork_creation import CreativeArtistAgent\nfrom teleAgent.models.agent_model.artwork_creation.dalle_draw import DalleDrawer\n\nclass ArtworkGenerator:\n    def __init__(self, config: dict):\n        self.artist = CreativeArtistAgent(\n            character_profile=\"creative and artistic\",\n            dalle_config=config[\"dalle\"],\n            llm_config=config[\"llm\"]\n        )\n        self.drawer = DalleDrawer(config[\"dalle\"])\n\n    async def generate_artwork(self, prompt: str) -&gt; dict:\n        \"\"\"Generate artwork from prompt\"\"\"\n        try:\n            # Generate enhanced prompt\n            enhanced_prompt = await self.artist.enhance_prompt(prompt)\n\n            # Generate image\n            artwork = await self.drawer.generate_image(enhanced_prompt)\n\n            return {\n                \"image_url\": artwork[\"url\"],\n                \"prompt\": enhanced_prompt,\n                \"metadata\": artwork[\"metadata\"]\n            }\n        except Exception as e:\n            logger.error(f\"Artwork generation failed: {e}\")\n            raise\n</code></pre>"},{"location":"tutorials/nft-creation/#step-2-nft-metadata-handling","title":"Step 2: NFT Metadata Handling","text":"<pre><code># nft/metadata.py\nfrom datetime import datetime\nimport json\n\nclass NFTMetadata:\n    def __init__(self, artwork_data: dict):\n        self.artwork_data = artwork_data\n\n    def generate_metadata(self) -&gt; dict:\n        \"\"\"Generate NFT metadata\"\"\"\n        return {\n            \"name\": f\"TeleAgent NFT #{int(time.time())}\",\n            \"description\": self.artwork_data[\"prompt\"],\n            \"image\": self.artwork_data[\"image_url\"],\n            \"attributes\": [\n                {\n                    \"trait_type\": \"Artist\",\n                    \"value\": \"TeleAgent AI\"\n                },\n                {\n                    \"trait_type\": \"Creation Date\",\n                    \"value\": datetime.now().isoformat()\n                }\n            ],\n            \"properties\": {\n                \"files\": [\n                    {\n                        \"uri\": self.artwork_data[\"image_url\"],\n                        \"type\": \"image/png\"\n                    }\n                ],\n                \"category\": \"image\",\n                \"creators\": [\n                    {\n                        \"address\": \"YOUR_CREATOR_ADDRESS\",\n                        \"share\": 100\n                    }\n                ]\n            }\n        }\n</code></pre>"},{"location":"tutorials/nft-creation/#step-3-nft-minting-implementation","title":"Step 3: NFT Minting Implementation","text":"<pre><code># nft/minter.py\nfrom solana.rpc.async_api import AsyncClient\nfrom solana.transaction import Transaction\nfrom spl.token.instructions import create_mint, mint_to\n\nclass NFTMinter:\n    def __init__(self, config: dict):\n        self.client = AsyncClient(config[\"rpc_url\"])\n        self.wallet = config[\"wallet\"]\n\n    async def mint_nft(self, metadata: dict) -&gt; str:\n        \"\"\"Mint NFT with provided metadata\"\"\"\n        try:\n            # Create mint transaction\n            mint_account = await self._create_mint_account()\n\n            # Upload metadata to IPFS/Arweave\n            metadata_url = await self._upload_metadata(metadata)\n\n            # Create mint instruction\n            mint_ix = create_mint(\n                mint_account.public_key(),\n                self.wallet.public_key(),\n                0,  # decimals\n                self.wallet.public_key()\n            )\n\n            # Send transaction\n            tx = Transaction().add(mint_ix)\n            result = await self.client.send_transaction(\n                tx,\n                self.wallet\n            )\n\n            return result[\"result\"]\n\n        except Exception as e:\n            logger.error(f\"Minting failed: {e}\")\n            raise\n</code></pre>"},{"location":"tutorials/nft-creation/#step-4-command-implementation","title":"Step 4: Command Implementation","text":"<pre><code># main.py\nfrom artwork.generator import ArtworkGenerator\nfrom nft.metadata import NFTMetadata\nfrom nft.minter import NFTMinter\n\nclass NFTCommands:\n    def __init__(self, client: TelegramClient):\n        self.client = client\n        self.generator = ArtworkGenerator(config)\n        self.minter = NFTMinter(config)\n\n    async def setup_handlers(self):\n        @self.client.on_command(\"create_nft\")\n        async def create_nft(message):\n            try:\n                # Send processing message\n                status_message = await self.client.send_message(\n                    chat_id=message.chat.id,\n                    text=\"\ud83c\udfa8 Generating your NFT...\"\n                )\n\n                # Generate artwork\n                artwork = await self.generator.generate_artwork(\n                    message.text\n                )\n\n                # Update status\n                await self.client.edit_message_text(\n                    chat_id=message.chat.id,\n                    message_id=status_message.message_id,\n                    text=\"\ud83d\uddbc\ufe0f Artwork generated! Creating NFT...\"\n                )\n\n                # Generate metadata\n                metadata = NFTMetadata(artwork).generate_metadata()\n\n                # Mint NFT\n                mint_result = await self.minter.mint_nft(metadata)\n\n                # Send success message\n                await self.client.send_photo(\n                    chat_id=message.chat.id,\n                    photo=artwork[\"image_url\"],\n                    caption=f\"\u2728 Your NFT has been created!\\n\"\n                           f\"Mint address: {mint_result}\"\n                )\n\n            except Exception as e:\n                await self.client.send_message(\n                    chat_id=message.chat.id,\n                    text=f\"\u274c Failed to create NFT: {str(e)}\"\n                )\n</code></pre>"},{"location":"tutorials/nft-creation/#step-5-nft-transfer-implementation","title":"Step 5: NFT Transfer Implementation","text":"<pre><code># nft/transfer.py\nclass NFTTransfer:\n    def __init__(self, config: dict):\n        self.client = AsyncClient(config[\"rpc_url\"])\n        self.wallet = config[\"wallet\"]\n\n    async def transfer_nft(\n        self,\n        mint_address: str,\n        recipient: str\n    ) -&gt; str:\n        \"\"\"Transfer NFT to recipient\"\"\"\n        try:\n            # Create transfer instruction\n            transfer_ix = spl.token.instructions.transfer(\n                mint_address,\n                self.wallet.public_key(),\n                recipient,\n                1  # amount (always 1 for NFTs)\n            )\n\n            # Send transaction\n            tx = Transaction().add(transfer_ix)\n            result = await self.client.send_transaction(\n                tx,\n                self.wallet\n            )\n\n            return result[\"result\"]\n\n        except Exception as e:\n            logger.error(f\"Transfer failed: {e}\")\n            raise\n</code></pre>"},{"location":"tutorials/nft-creation/#step-6-adding-transfer-commands","title":"Step 6: Adding Transfer Commands","text":"<pre><code>@client.on_command(\"transfer_nft\")\nasync def transfer_nft(message):\n    try:\n        # Parse command arguments\n        args = message.text.split()\n        if len(args) != 3:\n            raise ValueError(\n                \"Usage: /transfer_nft &lt;mint_address&gt; &lt;recipient_address&gt;\"\n            )\n\n        mint_address = args[1]\n        recipient = args[2]\n\n        # Send processing message\n        status_message = await client.send_message(\n            chat_id=message.chat.id,\n            text=\"\ud83d\udd04 Processing NFT transfer...\"\n        )\n\n        # Execute transfer\n        result = await nft_transfer.transfer_nft(\n            mint_address,\n            recipient\n        )\n\n        # Send success message\n        await client.edit_message_text(\n            chat_id=message.chat.id,\n            message_id=status_message.message_id,\n            text=f\"\u2705 NFT transferred successfully!\\n\"\n                 f\"Transaction: {result}\"\n        )\n\n    except Exception as e:\n        await client.send_message(\n            chat_id=message.chat.id,\n            text=f\"\u274c Transfer failed: {str(e)}\"\n        )\n</code></pre>"},{"location":"tutorials/nft-creation/#best-practices","title":"Best Practices","text":"<ol> <li> <p>Error Handling <code>python    try:        result = await operation()    except NFTMintError as e:        logger.error(f\"Minting error: {e}\")        # Implement retry logic    except TransferError as e:        logger.error(f\"Transfer error: {e}\")        # Notify user and suggest solutions</code></p> </li> <li> <p>Rate Limiting    ```python    from teleAgent.utilities.rate_limiter import RateLimiter</p> </li> </ol> <p>rate_limiter = RateLimiter(        max_requests=1,  # One NFT creation per minute        time_window=60    )</p> <p>@rate_limiter.limit    async def create_nft(message):        # NFT creation logic        pass    ```</p> <ol> <li>Metadata Storage <code>python    async def store_metadata(metadata: dict):        \"\"\"Store metadata in IPFS\"\"\"        ipfs_client = IPFSClient()        cid = await ipfs_client.add_json(metadata)        return f\"ipfs://{cid}\"</code></li> </ol>"},{"location":"tutorials/nft-creation/#testing","title":"Testing","text":"<pre><code># test_nft.py\nimport pytest\nfrom unittest.mock import AsyncMock, patch\n\n@pytest.mark.asyncio\nasync def test_nft_creation():\n    # Mock dependencies\n    artwork_mock = AsyncMock()\n    artwork_mock.generate_artwork.return_value = {\n        \"image_url\": \"http://example.com/image.png\",\n        \"prompt\": \"Test prompt\"\n    }\n\n    minter_mock = AsyncMock()\n    minter_mock.mint_nft.return_value = \"mint_address\"\n\n    # Test creation\n    result = await create_nft(artwork_mock, minter_mock, \"test prompt\")\n    assert result[\"mint_address\"] == \"mint_address\"\n</code></pre>"},{"location":"tutorials/nft-creation/#troubleshooting","title":"Troubleshooting","text":"<ol> <li>Artwork Generation Issues</li> <li>Check DALL-E API key</li> <li>Verify prompt formatting</li> <li> <p>Monitor rate limits</p> </li> <li> <p>Minting Problems</p> </li> <li>Check wallet balance</li> <li>Verify network connection</li> <li> <p>Validate metadata format</p> </li> <li> <p>Transfer Issues</p> </li> <li>Verify ownership</li> <li>Check recipient address</li> <li>Confirm gas fees</li> </ol>"},{"location":"tutorials/nft-creation/#next-steps","title":"Next Steps","text":"<ol> <li>Implement additional features:</li> <li>NFT collections</li> <li>Batch minting</li> <li> <p>Royalties</p> </li> <li> <p>Add advanced functionality:</p> </li> <li>Secondary market</li> <li>Price discovery</li> <li> <p>Automated trading</p> </li> <li> <p>Explore other tutorials:</p> </li> <li>Group Chat Integration</li> <li>Bargaining System </li> </ol>"},{"location":"tutorials/telegram-bot/","title":"Telegram Bot Tutorial","text":"<p>This tutorial explains the key components of the TeleAgent Telegram bot implementation.</p>"},{"location":"tutorials/telegram-bot/#core-features","title":"Core Features","text":""},{"location":"tutorials/telegram-bot/#1-response-handling","title":"1. Response Handling","text":"<p>The bot uses a flexible <code>TelegramResponse</code> class to handle different types of responses:</p> <pre><code>@dataclass\nclass TelegramResponse:\n    text: Optional[str] = None\n    image: Optional[Union[str, bytes, BinaryIO]] = None\n    caption: Optional[str] = None\n    video: Optional[Union[str, bytes, BinaryIO]] = None\n    audio: Optional[Union[str, bytes, BinaryIO]] = None\n    document: Optional[Union[str, bytes, BinaryIO]] = None\n</code></pre> <p>This allows sending: - Text-only messages - Images with captions - Combined text and media messages - Various media types (images, videos, audio, documents)</p>"},{"location":"tutorials/telegram-bot/#2-available-commands","title":"2. Available Commands","text":"<p>The bot supports these main commands:</p> <pre><code>/start      - Start interaction with the bot\n/help       - Show available commands\n/profile    - View agent profile &amp; style\n/mint       - Check latest minted NFTs\n/nfts       - View agent's NFT collection\n/balance    - Check token balance\n</code></pre>"},{"location":"tutorials/telegram-bot/#3-message-handling","title":"3. Message Handling","text":"<p>Messages are processed through the <code>handle_message</code> method which: - Receives updates from Telegram - Processes messages through the agent service - Handles both private and group chat messages - Supports response delays for group chats</p> <p>Example usage:</p> <pre><code>@bot.message_handler(func=lambda message: True)\nasync def handle_message(update: Update, context):\n    response = await agent_service.get_response(\n        bot_id=context.bot.id,\n        update=update,\n        message=update.message.text\n    )\n    await message_reply(chat_id, response)\n</code></pre>"},{"location":"tutorials/telegram-bot/#4-group-chat-support","title":"4. Group Chat Support","text":"<p>The bot includes special handling for group chats: - Maintains group chat intervals - Processes bot responses in groups - Supports multi-bot interactions - Implements rate limiting</p>"},{"location":"tutorials/telegram-bot/#5-redis-integration","title":"5. Redis Integration","text":"<p>For message queueing and persistence:</p> <pre><code># Push message to queue\n/push_redis &lt;message&gt;\n\n# Pop message from queue\n/pop_redis\n</code></pre>"},{"location":"tutorials/telegram-bot/#basic-setup","title":"Basic Setup","text":"<ol> <li>Initialize the bot with required services:</li> </ol> <pre><code>bot = TelegramBot(\n    agent_service=agent_service,\n    wallet_service=wallet_service,\n    nft_service=nft_service,\n    bot_config=config\n)\n</code></pre> <ol> <li>Set up command handlers:</li> </ol> <pre><code>self.application.add_handler(CommandHandler(\"start\", self.start))\nself.application.add_handler(CommandHandler(\"help\", self.help))\n# ... additional handlers\n</code></pre> <ol> <li>Start the bot:</li> </ol> <pre><code>await bot.initialize()\n</code></pre>"},{"location":"tutorials/telegram-bot/#important-notes","title":"Important Notes","text":"<ul> <li>Ensure privacy mode is disabled via @BotFather</li> <li>Configure proper error handling</li> <li>Set up appropriate rate limiting for group chats</li> <li>Handle media responses appropriately</li> <li>Maintain proper service dependencies</li> </ul> <p>For more details, refer to the implementation in <code>telegram.py</code>. </p>"}]}